module flink_list_m

   use datatypes, only: particles, interactions
   use param, only: f, hsml, dim

   use cudafor

   private
   integer, parameter:: maxpcell = 64

   public:: flink_list

contains

   !==============================================================================================================================
   subroutine flink_list(scale_k, maxinter_perp, n_p, parts_d, niac_d, pairs_d)
      ! save as above, but for 3D
      
      use thrust

      implicit none
      real(f), intent(in):: scale_k
      integer, intent(in):: n_p, maxinter_perp
      type(particles), device, intent(inout):: parts_d(n_p)
      integer, device, intent(out):: niac_d(n_p)
      type(interactions), device, intent(out):: pairs_d(maxinter_perp, n_p)
      integer, allocatable, device:: cellLoc(:,:)
      integer:: i, j, k, d, istat, ngridx(dim)
      real(f):: mingridx(dim), maxgridx(dim), dcell
      integer, device:: ngridx_d(dim), gridCellHash(n_p), mapping(n_p)
      real(f), device:: mingridx_d(dim), maxgridx_d(dim), minx, miny, minz, maxx, maxy, maxz, x(dim,n_p)
      integer, managed:: ierr
      type(particles), device:: partstmp_d(n_p)

      dcell = scale_k*hsml
      minx = HUGE(1._f); miny = HUGE(1._f); minz = HUGE(1._f)
      maxx = -HUGE(1._f); maxy = -HUGE(1._f); maxz = -HUGE(1._f)
      !Determining bounding box extents
      !$cuf kernel do <<<*,*>>>
      do i = 1, n_p
         minx = min(minx, parts_d(i)%x(1))
         miny = min(miny, parts_d(i)%x(2))
         minz = min(minz, parts_d(i)%x(3))
         maxx = max(maxx, parts_d(i)%x(1))
         maxy = max(maxy, parts_d(i)%x(2))
         maxz = max(maxz, parts_d(i)%x(3))
      end do
      mingridx(1) = minx - dcell; mingridx(2) = miny - dcell; mingridx(3) = minz - dcell
      maxgridx(1) = maxx + dcell; maxgridx(2) = maxy + dcell; maxgridx(3) = maxz + dcell
      ngridx(:) = int((maxgridx(:) - mingridx(:))/dcell) + 1
      maxgridx(:) = mingridx(:) + ngridx*dcell
      ngridx_d(:) = ngridx(:)
      mingridx_d = mingridx
      maxgridx_d = maxgridx

      allocate (cellLoc(2,ngridx(1)*ngridx(2)*ngridx(3)))
      !$cuf kernel do (1) <<<*,*>>>
      do i = 1,ngridx(1)*ngridx(2)*ngridx(3)
         cellLoc(1,i) = 0
         cellLoc(2,i) = -1
      end do
      
      !$cuf kernel do
      do i = 1,n_p
         x(:,i) = parts_d(i)%x(:)
      end do
      
      call map2Grid<<<n_p/1024 + 1, 1024>>>(dcell, x, ngridx_d, gridCellHash, mingridx_d, n_p)
      
      !$cuf kernel do <<<*,1024>>>
      do i = 1,n_p
         mapping(i) = i
      end do
  
      !call thrustsortbykey(gridCellHash, parts_d, np)
      call thrustsortbykey(gridCellHash, mapping, n_p)
      
      !$cuf kernel do
      do i = 1,n_p
         partstmp_d(i) = parts_d(mapping(i))
      end do
      
      !$cuf kernel do
      do i = 1,n_p
         parts_d(i) = partstmp_d(i)
      end do
      
      !$cuf kernel do
      do i = 1,n_p
         do d = 1,dim
            x(d,i) = parts_d(i)%x(d)
         end do
      end do
      
      !$cuf kernel do <<<*,1024>>>
      do i = 1, n_p
      
         if (i == 1) then
           cellLoc(1,gridCellHash(i)) = 1
         elseif (gridCellHash(i-1) /= gridCellHash(i)) then
           cellLoc(1,gridCellHash(i)) = i
         end if
        
         if (i == n_p) then
           cellLoc(2,gridCellHash(i)) = n_p
         elseif (gridCellHash(i+1) /= gridCellHash(i)) then
           cellLoc(2,gridCellHash(i)) = i
         end if
        
      end do

      ierr = 0
      call sweep <<< n_p/32 + 1, 32 >>> (maxinter_perp, scale_k, ngridx_d, n_p, x, parts_d, gridCellHash, cellLoc, niac_d, pairs_d, ierr)
      if (ierr == 1) then
         print *, ' >>> Error <<< : Too many interactions'
         stop
      end if

   end subroutine flink_list

   !=================================================================================================================================
   attributes(global) subroutine map2Grid(dc, x, ncells, gridCellHash, mingridx, n)
   
      implicit none
      real, value:: dc
      real, intent(in):: x(:,:)
      real, intent(in):: mingridx(dim)
      integer, intent(in):: ncells(dim)
      integer, intent(out):: gridCellHash(:)
      integer:: d, i, ip, icell(dim)
      integer, value:: n
     
      i = blockDim%x * (blockIdx%x - 1) + threadIdx%x
      if (i <= n) then
        icell(:) = int((x(:,i) - mingridx(:))/dc) + 1
        gridCellHash(i) = cells2Hash(icell, ncells)
      end if
     
   end subroutine map2Grid

   !==============================================================================================================================
   attributes(global) subroutine sweep(maxint, sk, ngx, np, x, pts, gridCellHash, cellLoc, nij, pij, ierr)

      implicit none
      integer, intent(in), value:: np, maxint
      real(f), intent(in), value:: sk
      real(f), intent(in):: x(dim,np)
      type(particles), intent(in):: pts(np)
      integer, intent(in):: gridCellHash(np), cellLoc(:,:), ngx(dim)
      integer, intent(inout):: ierr
      integer, intent(out):: nij(np)
      type(interactions), intent(out):: pij(maxint, np)
      integer:: i, j, k, d, icell(dim), jcell(dim), hashAdj
      integer, parameter:: sweepinds(3, 13) = reshape((/-1,-1,-1, &
                                                         0,-1,-1, &
                                                         1,-1,-1, &
                                                        -1, 0,-1, &
                                                         0, 0,-1, &
                                                         1, 0,-1, &
                                                        -1, 1,-1, &
                                                         0, 1,-1, &
                                                         1, 1,-1, &
                                                        -1,-1, 0, &
                                                         0,-1, 0, &
                                                         1,-1, 0, &
                                                        -1, 0, 0/) , (/3, 13/))

      i = blockDim%x*(blockIdx%x - 1) + threadIdx%x

      ! Beginning sweep
      if (i <= np) then
         nij(i) = 0
         do j = cellLoc(1,gridCellHash(i)), cellLoc(2,gridCellHash(i))
            if (j>i) then
               call check_if_interact(maxint, sk, pts(i), pts(j), nij(i), pij(:, i), ierr)
            end if
         end do
         icell = hash2Cell(gridCellHash(i), ngx)
         do k = 1, 13
            jcell = icell(:) + sweepinds(:,k)
            hashAdj = cells2Hash(jcell, ngx)
            do j = cellLoc(1,hashAdj), cellLoc(2,hashAdj)
               call check_if_interact(maxint, sk, pts(i), pts(j), nij(i), pij(:, i), ierr)
            end do
         end do
      end if

   end subroutine sweep

   !==============================================================================================================================
   attributes(device) subroutine check_if_interact(maxint, sk, p_i, p_j, nij, pij, ierr)
      ! subroutine to chekc if two particles are interacting and consequently adding to pair list

      implicit none
      integer, intent(in):: maxint
      real(f), intent(in):: sk
      type(particles), intent(in):: p_i, p_j
      integer, intent(inout):: nij, ierr
      type(interactions), intent(inout):: pij(maxint)
      integer:: tmp
      real(f):: dxiac(dim), r

      ! only consider interactions when real particles are involved
      if (p_i%itype == 1 .or. p_j%itype == 1) then
         
         dxiac(:) = p_i%x(:) - p_j%x(:)
         r = SQRT(SUM(dxiac*dxiac))
         if (r < hsml*sk) then
            nij = nij + 1
            if (nij < maxint) then
               pij(nij)%j = p_j%indloc
               call kernel(r, dxiac(:), hsml, pij(nij)%w, pij(nij)%dwdx(:))
            else
               tmp = atomicexch(ierr, 1)
            end if
         end if
      end if

   end subroutine check_if_interact

   !==============================================================================================================================
   attributes(device) pure subroutine kernel(r, dx, thsml, tw, tdwdx)
      ! Contains the kernels

      use param, only: skf, pi, dims => dim

      implicit none
      real(f), intent(in):: dx(dims), r, thsml
      real(f), intent(out):: tdwdx(dims), tw
      real(f):: q, factor

      q = r/thsml

      SELECT CASE (SKF)
      CASE (1) ! cubic
         if (dims == 2) factor = 10._f/(7._f*pi*thsml*thsml)
         if (dims == 3) factor = 1_f/(pi*thsml*thsml*thsml)
         tw = factor*(0.25_f*MAX(0._f, 2._f - q)**3 - MAX(0._f, 1._f - q)**3)
         tdwdx = -factor*3._f*(0.25_f*MAX(0._f, 2._f - q)**2 - MAX(0._f, 1._f - q)**2)*dx(:)/(r*thsml)
      CASE (2) ! quartic
         if (dims == 2) factor = 96_f/(1199_f*pi*thsml*thsml)
         if (dims == 3) factor = 1_f/(20_f*pi*thsml*thsml*thsml)
         tw = factor*(MAX(0._f, 2.5_f - q)**4 - 5_f*MAX(0._f, 1.5_f - q)**4 + 10_f*MAX(0._f, 0.5_f - q)**4)
         tdwdx(:) = &
            -factor*4._f*(MAX(0._f, 2.5_f - q)**3 - 5_f*MAX(0._f, 1.5_f - q)**3 + 10_f*MAX(0._f, 0.5_f - q)**3)*dx(:)/(r*thsml)
      CASE (3) ! quintic
         if (dims == 2) factor = 7_f/(478_f*pi*thsml*thsml)
         if (dims == 3) factor = 1_f/(120_f*pi*thsml*thsml*thsml)
         tw = factor*(MAX(0._f, 3._f - q)**5 - 6._f*MAX(0._f, 2._f - q)**5 + 15._f*MAX(0._f, 1._f - q)**5)
         tdwdx(:) = &
            -factor*5._f*(MAX(0._f, 3._f - q)**4 - 6._f*MAX(0._f, 2._f - q)**4 + 15._f*MAX(0._f, 1._f - q)**4)*dx(:)/(r*thsml)
      CASE (4) ! Wenland Quintic C2
         if (dims == 2) factor = 7._f/(64._f*pi*thsml*thsml)
         if (dims == 3) factor = 21._f/(256._f*pi*thsml*thsml*thsml)
         tw = factor*MAX(0._f, 2._f - q)**4*(2._f*q + 1._f)
         tdwdx(:) = -factor*10._f*q*MAX(0._f, 2._f - q)**3*dx(:)/(r*thsml)
      CASE (5) ! Wenland Quintic C4
         if (dims == 2) factor = 3._f/(1024._f*pi*thsml*thsml)
         if (dims == 3) factor = 165._f/(65536._f*pi*thsml*thsml*thsml)
         tw = factor*MAX(0._f, 2._f - q)**6*(35._f*q**2 + 36._f*q + 12._f)
         tdwdx(:) = -factor*56._f*q*MAX(0._f, 2._f - q)**5*(5._f*q + 2._f)*dx(:)/(r*thsml)
      CASE (6) ! Wenland Quintic C6
         if (dims == 2) factor = 39._f/(14336._f*pi*thsml*thsml)
         if (dims == 3) factor = 1365._f/(524288._f*pi*thsml*thsml*thsml)
         tw = factor*MAX(0._f, 2._f - q)**8*(16._f*q**3 + 25_f*q**2 + 16._f*q + 4._f)
         tdwdx(:) = -factor*22._f*q*(8._f*q**2 + 7._f*q + 2._f)*MAX(0._f, 2._f - q)**7*dx(:)/(r*thsml)
      CASE (7) ! gaussian
         factor = 1_f/(thsml**dims*pi**(0.5_f*dims))
         if (q .ge. 0_f .and. q .le. 3_f) then
            tw = factor*exp(-q*q)
            tdwdx(:) = tw*2_f*dx(:)/(thsml*thsml)
         end if

      END SELECT

   end subroutine kernel
   
   !=================================================================================================================================
   attributes(device) pure function cells2Hash(cellCoords, ncells) result(hash)
     
      implicit none
      integer, intent(in):: cellCoords(dim), ncells(dim)
      integer:: hash
     
      hash = ncells(1)*ncells(2)*(cellCoords(3) - 1) + ncells(1)*(cellCoords(2) - 1) + cellCoords(1)
     
   end function cells2Hash
   
   !=================================================================================================================================
   attributes(device) pure function hash2Cell(hash, ncells) result(cellCoords)
   
      implicit none
      integer, intent(in):: hash, ncells(dim)
      integer:: cellCoords(3), nxy, modhashnxy
     
      nxy = ncells(1)*ncells(2)
      modhashnxy = mod(hash-1,nxy)
     
      cellCoords(3) = int((hash-1)/nxy) + 1
      cellCoords(2) = mod(hash-1,nxy)/ncells(1) + 1
      cellCoords(1) = mod(modhashnxy,ncells(1)) + 1
     
   end function hash2Cell

end module flink_list_m
