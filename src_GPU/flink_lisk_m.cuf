module flink_list_m
	
    use datatypes, only: particles,interactions
	use globvar, only: parts_d,pairs_d,niac_d,ntotal_d,nvirt_d,maxinter_perp,scale_k,ntotal,nvirt,ntotal_d,nvirt_d,maxpcell,scale_k_d,niac,pairs,test_time
	use param, only: dim,f,hsml
    
    use cudafor
	
!~ 	use kernel_m, only: kernel
	
    integer,parameter:: maxpcell3D=64,maxpcell2D=16
    
    type particleincellarray
        type(particles),pointer:: p
    end type particleincellarray
	
	public:: flink_list,particleincellarray
	private:: check_if_interact,flink_list2D,flink_list3D,bounding_box

contains
	
	!==============================================================================================================================
	subroutine flink_list
	! interface subroutine for 2D and 3D cases
		implicit none
		
!~ 		select case (dim)
!~ 			case(2)
!~ 				call flink_list2D
!~ 			case(3)
				call flink_list3D
!~ 		end select
		
	end subroutine flink_list
	
	!==============================================================================================================================
!~ 	subroutine flink_list2D( )
	! subroutine to search for particle interactions using cell-linked list.
		
!~ 		implicit none
!~         integer,allocatable,device:: pincell(:,:)
!~         integer:: i,j,k,istat
!~ 		type(particleincellarray),allocatable,device:: cells(:,:,:)
													
!~ 		call bounding_box<<<ceiling((ntotal+nvirt)/real(blocksize))>>>(mingridx,maxgridx,ngridx,dcell)
		
!~ 		allocate( pincell(ngridx(1),ngridx(2)),&
!~ 					cells(maxpcell,ngridx(1),ngridx(2)) )
					
!~ 		!Mapping particles to grid cells
!~ 		call zero_pincell<<<product(ngridx(:))/ngridx(dim),ngridx(dim)>>>(ngridx,pincell)
		
!~ 		do i=1,ntotal+nvirt
!~ 			icell = int((parts(i)%x(1) - mingridx(1))/dcell) + 1
!~ 			jcell = int((parts(i)%x(2) - mingridx(2))/dcell) + 1 
!~ 			pincell(icell,jcell) = pincell(icell,jcell) + 1
!~ 			cells(pincell(icell,jcell),icell,jcell)%p => parts(i)
!~ 		enddo
		
		! Searching for interactions. Algorithm loops through every cell with indices icell,jcell.
		! First checks particles within cell are interacting, then checks particles interacting with
		! particles in adjacent cells. 
!~ 		niac = 0
!~ 		do icell = 2,ngridx(1)-2
!~ 			do jcell = 2,ngridx(2)-2
			
!~ 				! finding pairs within cell icell,jcell
!~ 				do i = 1,pincell(icell,jcell)-1
!~ 					do j = i+1,pincell(icell,jcell)
!~ 						call check_if_interact(cells(i,icell,jcell)%p,cells(j,icell,jcell)%p)
!~ 					end do
!~ 				end do
				
!~ 				! finding pairs between particles in cell icell,jcell and particles in cell xi,yi
!~ 				do k = 1,4
!~ 					xi = icell + sweep(1,k)
!~ 					yi = jcell + sweep(2,k)
!~ 					do i = 1,pincell(icell,jcell)
!~ 						do j = 1,pincell(xi,yi)
!~ 							call check_if_interact(cells(i,icell,jcell)%p,cells(j,xi,yi)%p)
!~ 						end do
!~ 					end do
!~ 				end do
				
!~ 			end do
!~ 		end do
	
!~ 	end subroutine flink_list2D
	
	!==============================================================================================================================
	subroutine flink_list3D( )
	! save as above, but for 3D
		
		implicit none
		integer,allocatable,device:: pincell(:,:,:)
        integer:: i,j,k,d,istat
        type(particleincellarray),allocatable,device:: cells(:,:,:,:)
        type(dim3),parameter:: nthreads=dim3(8,8,8)
        type(dim3):: nblocks
        real(f),managed:: dcell
        integer:: ngridx(dim),mingridind(dim),maxgridind(dim)
        integer,device:: ngridx_d(dim),mingridind_d(dim),maxgridind_d(dim)
        integer,device,allocatable:: gridind(:,:)
        
        dcell = scale_k*hsml
        allocate(gridind(dim,ntotal+nvirt))
        call determine_gridinds<<<(ntotal+nvirt)/1024+1,1024>>>(dcell,ntotal_d,nvirt_d,parts_d,gridind)

		!Determining bounding box extents
!~ 		call bounding_box(mingridx,maxgridx,ngridx,dcell)
        mingridind_d(:) = HUGE(1)
        maxgridind_d(:) = -HUGE(1)
        !$cuf kernel do (2) <<<,>>>
        do i = 1,ntotal+nvirt
            do d = 1,dim
                mingridind_d(d) = min(gridind(d,i)-1,mingridind_d(d))
                maxgridind_d(d) = max(gridind(d,i)+1,maxgridind_d(d))
            end do
        end do
        write(*,*) 'test'
        mingridind = mingridind_d
        maxgridind = maxgridind_d
        ngridx(:) = maxgridind(:) - mingridind(:) + 1
        ngridx_d(:) = ngridx(:)
        
		allocate( pincell(mingridind(1):maxgridind(1),mingridind(2):maxgridind(2),mingridind(3):maxgridind(3)),&
					cells(maxpcell3D,mingridind(1):maxgridind(1),mingridind(2):maxgridind(2),mingridind(3):maxgridind(3)) )
        
        nblocks = dim3(ngridx(1)/nthreads%x+1,ngridx(2)/nthreads%y+1,ngridx(3)/nthreads%y+1)
        
        call zero_pincell3D<<<nblocks,nthreads>>>(ngridx_d,pincell)
        
        call populate3D<<<(ntotal+nvirt)/32+1,32>>>(ntotal_d,nvirt_d,mingridind_d,maxgridind_d,parts_d,gridind,pincell,cells)

        call sweep3D<<<(ntotal+nvirt)/32+1,32>>>(ntotal_d,nvirt_d,mingridind_d,maxgridind_d,parts_d,gridind,pincell,cells,niac_d,pairs_d)

        deallocate( pincell,cells )
		
	end subroutine flink_list3D
    
    !==============================================================================================================================
    attributes(global) subroutine determine_gridinds(dc,nt,nv,pts,ginds)
    
        implicit none
        real(f),intent(in):: dc
        integer,intent(in):: nt,nv
        type(particles),intent(in):: pts(nt+nv)
        integer,intent(out):: ginds(dim,nt+nv)
        real(f):: refpoint(dim)
        integer:: i
        
        i = blockDim%x*(blockIdx%x-1)+threadIdx%x
        if (i <= nt+nv) then
            refpoint(:) = pts(1)%x(1:dim)
            ginds(:,i) = int((pts(i)%x(:)-refpoint(:))/dc) + 1
        end if
        
    end subroutine determine_gridinds
    
	!==============================================================================================================================
    attributes(global) subroutine zero_pincell3D(ng,p)
    ! helper function to zero pincell array on GPU
    
        implicit none
        integer,intent(in):: ng(dim)
        integer,intent(out):: p(ng(1),ng(2),ng(3))
        integer:: i,j,k
        
        i = blockDim%x*(blockIdx%x-1)+threadIdx%x
        j = blockDim%y*(blockIdx%y-1)+threadIdx%y
        k = blockDim%z*(blockIdx%z-1)+threadIdx%z
        if ( i <= ng(1) .and. j <= ng(2) .and. k <= ng(3) ) p(i,j,k) = 0
        
    end subroutine zero_pincell3D
    
    !==============================================================================================================================
    attributes(global) subroutine populate3D(nt,nv,mingind,maxgind,pts,gind,p,c)
    
        implicit none
        integer,intent(in):: nt,nv,mingind(dim),maxgind(dim),gind(dim,nt+nv)
        type(particles),intent(in),target:: pts(nt+nv)
        integer,intent(inout):: p(mingind(1):maxgind(1),mingind(2):maxgind(2),mingind(3):maxgind(3))
        type(particleincellarray),intent(out):: c(maxpcell3D,mingind(1):maxgind(1),mingind(2):maxgind(2),mingind(3):maxgind(3))
        integer:: ind,icell,jcell,kcell,i,j,k,d
        
        ! global thread index
        i = blockDim%x*(blockIdx%x-1)+threadIdx%x
        if (i<=nt+nv) then
            icell = gind(1,i); jcell = gind(2,i); kcell = gind(3,i)
            ind = atomicadd(p(icell,jcell,kcell),1)
            c(ind+1,icell,jcell,kcell)%p => pts(i)
        end if

    end subroutine populate3D

    !==============================================================================================================================
    attributes(global) subroutine sweep3D(nt,nv,mingind,maxgind,pts,gind,p,c,nij,pij)
    
        implicit none
        integer,intent(in):: nt,nv,mingind(dim),maxgind(dim),gind(dim,nt+nv),&
            p(mingind(1):maxgind(1),mingind(2):maxgind(2),mingind(3):maxgind(3))
        type(particleincellarray),intent(in):: c(maxpcell3D,mingind(1):maxgind(1),mingind(2):maxgind(2),mingind(3):maxgind(3)) 
        type(particles),intent(in),target:: pts(nt+nv)
        integer,intent(out):: nij(nt+nv)
        type(interactions),intent(out):: pij(maxinter_perp,nt+nv)
        integer:: i,j,k,d,xi,yi,zi,icell,jcell,kcell
        integer,parameter:: sweep(3,13) = reshape((/-1,-1,-1,&
													-1,-1, 0,&
													-1,-1, 1,&
													-1, 0,-1,&
													-1, 0, 0,&
													-1, 0, 1,&
													-1, 1,-1,&
													-1, 1, 0,&
													-1, 1, 1,&
													 0,-1,-1,&
													 0,-1, 0,&
													 0,-1, 1,&
													 0, 0,-1/),(/3,13/))
        
        i = blockDim%x*(blockIdx%x-1)+threadIdx%x
        
        ! Beginning sweep
        if (i<=nt+nv) then
            nij(i) = 0
            icell = gind(1,i)
            jcell = gind(2,i)
            kcell = gind(3,i)
            if (p(icell,jcell,kcell) > 1) then
                do j = 1,p(icell,jcell,kcell)
                    if (c(j,icell,jcell,kcell)%p%ind > i) then
                        ! only consider interactions when real particles are involved
                        call check_if_interact(pts(i),c(j,icell,jcell,kcell)%p,nij(i),pij(:,i))
                    end if
                end do
            end if
            do k = 1,13
                xi = icell + sweep(1,k)
                yi = jcell + sweep(2,k)
                zi = kcell + sweep(3,k)
                do j = 1,p(xi,yi,zi)
                    ! only consider interactions when real particles are involved
                    call check_if_interact(pts(i),c(j,xi,yi,zi)%p,nij(i),pij(:,i))
                end do
            end do
        end if
        
    end subroutine sweep3D
	
	!==============================================================================================================================
	attributes(device) subroutine check_if_interact(p_i,p_j,nij,pij)
	! subroutine to chekc if two particles are interacting and consequently adding to pair list
		
		implicit none
		type(particles),target,intent(in):: p_i,p_j
        integer,intent(inout):: nij
        type(interactions),intent(inout):: pij(maxinter_perp)
		real(f):: dxiac(dim),r
        
		! only consider interactions when real particles are involved
		if ( p_i%ind/=p_j%ind .and. (p_i%itype > 0 .or. p_j%itype > 0)) then
			dxiac(:) = p_i%x(:) - p_j%x(:)
			r = SQRT(SUM(dxiac*dxiac))
			if (r < hsml*scale_k_d) then
				nij = nij + 1
				if (nij < maxinter_perp) then
					pij(nij)%i => p_i!%ind
					pij(nij)%j => p_j!%ind
					call kernel(r,dxiac(:),hsml,pij(nij)%w,pij(nij)%dwdx(:))
				else
					print *,' >>> Error <<< : Too many interactions'
					stop
				end if
			end if
		end if
		
	end subroutine check_if_interact
	
	!==============================================================================================================================
	attributes(device) subroutine kernel(r,dx,thsml,tw,tdwdx)   
	! Contains the kernels
	
		use param, 		only: skf,pi
	
		implicit none
		real(f),intent(in):: dx(dim),r,thsml
		real(f),intent(out):: tdwdx(dim),tw
		real(f):: q,factor
		
		q = r/thsml
		tw = 0_f
		tdwdx(:) = 0_f
		
		SELECT CASE (SKF)
			CASE (1) ! cubic
				select case (dim)
					case(2)
						factor = 10_f/(7_f*pi*thsml*thsml)
					case(3)
						factor = 1_f/(pi*thsml*thsml)
				end select
				if (q.ge.0_f .and. q.lt.1_f) then          
					tw = factor * (1_f - 1.5_f*q*q + 0.75_f*q**3)
					tdwdx(:) = factor * (-3_f*q + 2.25_f*q*q) * dx(:) / (thsml*r)
				else if (q.ge.1_f .and. q.lt.2_f) then
					tw = factor * 0.25_f * (2_f-q)**3
					tdwdx(:) = -factor*0.75_f*((2_f-q)**2)*dx(:) / (thsml*r)        
				end if
			CASE (2) ! gaussian
				factor = 1_f/(thsml**dim*pi**(0.5_f*dim))
				if (q.ge.0_f .and. q.le.3_f) then
					tw = factor*exp(-q*q)
					tdwdx(:) = tw*2_f*dx(:)/(thsml*thsml)
				end if
		END SELECT
		
	end subroutine kernel
    
end module flink_list_m
