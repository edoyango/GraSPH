module flink_list_m

   use datatypes, only: particles, interactions
   use param, only: f, hsml, dim

   use cudafor

   private
   real(f), parameter:: skin=0.05_f

   public:: flink_list, kernel_k

contains

   !==============================================================================================================================
   subroutine flink_list(ind_d, itype_d, x_d, vx_d, rho_d, p_d, scale_k, maxinter, n_p, niac_d, pairs_d, xsincelast)
      ! save as above, but for 3D
      
      use thrust

      implicit none
      real(f), intent(in):: scale_k
      integer, intent(in):: n_p, maxinter
      integer, device, intent(inout):: ind_d(n_p), itype_d(n_p)
      real(f), device, intent(inout):: x_d(dim, n_p), vx_d(dim, n_p), rho_d(n_p), p_d(n_p), xsincelast(dim, n_p)
      integer, device, intent(inout):: niac_d
      type(interactions), device, intent(inout):: pairs_d(maxinter)
      integer, allocatable, device:: cellLoc(:,:)
      integer:: i, j, k, d, istat, ngridx(dim)
      real(f):: mingridx(dim), maxgridx(dim), dcell
      integer, device:: ngridx_d(dim), gridCellHash(n_p), j_d, mapping(n_p), itype_tmp(n_p), ind_tmp(n_p)
      real(f), device:: mingridx_d(dim), maxgridx_d(dim), minx, miny, minz, maxx, maxy, maxz, p_tmp(n_p), rho_tmp(n_p), x_tmp(dim,n_p), vx_tmp(dim,n_p), rsincelast_d, r, dx(dim), hsml_d
      real(f):: rsincelast
      
      dcell = (1._f+skin)*scale_k*hsml

         rsincelast_d = 0._f
         !$cuf kernel do (2) reduce(max:rsincelast_d)
         do i = 1,n_p
            do d = 1,dim
               rsincelast_d = max(rsincelast_d, (x_d(d,i)-xsincelast(d,i))**2)
            end do
         end do
         rsincelast = rsincelast_d
         if (rsincelast <= skin*skin*scale_k*hsml*scale_k*hsml) then
            hsml_d = hsml
            call update_wdwdx<<<niac_d/1024+1, 1024>>>(hsml, n_p, niac_d, x_d, pairs_d)
            return
         end if

      minx = HUGE(1._f); miny = HUGE(1._f); minz = HUGE(1._f)
      maxx = -HUGE(1._f); maxy = -HUGE(1._f); maxz = -HUGE(1._f)
      !Determining bounding box extents
      !$cuf kernel do <<<*,*>>> reduce(max:maxx,maxy,maxz) reduce(min:minx,miny,minz)
      do i = 1, n_p
         minx = min(minx, x_d(1,i))
         maxx = max(maxx, x_d(1,i))
         miny = min(miny, x_d(2,i))
         maxy = max(maxy, x_d(2,i))
         minz = min(minz, x_d(3,i))
         maxz = max(maxz, x_d(3,i))
      end do
      mingridx(1) = minx - 2.*dcell; mingridx(2) = miny - 2.*dcell; mingridx(3) = minz - 2.*dcell
      maxgridx(1) = maxx + 1.*dcell; maxgridx(2) = maxy + 1.*dcell; maxgridx(3) = maxz + 1.*dcell
      ngridx(:) = int((maxgridx(:) - mingridx(:))/dcell) + 1
      maxgridx(:) = mingridx(:) + ngridx*dcell
      ngridx_d(:) = ngridx(:)
      mingridx_d = mingridx
      maxgridx_d = maxgridx
      
      allocate (cellLoc(2,ngridx(1)*ngridx(2)*ngridx(3)))
      !$cuf kernel do (1) <<<*,*>>>
      do i = 1,ngridx(1)*ngridx(2)*ngridx(3)
         cellLoc(1,i) = 0
         cellLoc(2,i) = -1
      end do
      
      call map2Grid<<<n_p/1024 + 1, 1024>>>(x_d, dcell, ngridx_d, gridCellHash, mingridx_d, n_p)
      
      !$cuf kernel do <<<*,1024>>>
      do i = 1,n_p
         mapping(i) = i
      end do
      
      !call thrustsortbykey(gridCellHash, parts_d, np)
      call thrustsortbykey(gridCellHash, mapping, n_p)
      
      !$cuf kernel do <<<*,*>>>
      do i = 1,n_p
         j_d = mapping(i)
         itype_tmp(i) = itype_d(j_d)
         ind_tmp(i) = ind_d(j_d)
         p_tmp(i) = p_d(j_d)
         rho_tmp(i) = rho_d(j_d)
         do d = 1,dim
           x_tmp(d,i) = x_d(d,j_d)
           vx_tmp(d,i) = vx_d(d,j_d)
         end do
      end do
      
      !$cuf kernel do
      do i = 1,n_p
         itype_d(i) = itype_tmp(i)
         ind_d(i) = ind_tmp(i)
         p_d(i) = p_tmp(i)
         rho_d(i) = rho_tmp(i)
         x_d(:,i) = x_tmp(:,i)
         vx_d(:,i) = vx_tmp(:,i)
      end do
      
      !$cuf kernel do <<<*,1024>>>
      do i = 1, n_p
      
         if (i == 1) then
           cellLoc(1,gridCellHash(i)) = 1
         elseif (gridCellHash(i-1) /= gridCellHash(i)) then
           cellLoc(1,gridCellHash(i)) = i
         end if
        
         if (i == n_p) then
           cellLoc(2,gridCellHash(i)) = n_p
         elseif (gridCellHash(i+1) /= gridCellHash(i)) then
           cellLoc(2,gridCellHash(i)) = i
         end if
        
      end do
      ! i = 0
      niac_d = 0
      call sweep <<< n_p/64 + 1, 64 >>> (x_d, itype_d, maxinter, scale_k, ngridx_d, n_p, gridCellHash, cellLoc, niac_d, pairs_d)

      xsincelast = x_d

   end subroutine flink_list

   !=================================================================================================================================
   attributes(global) subroutine map2Grid(x, dc, ncells, gridCellHash, mingridx, n)
   
      implicit none
      real(f), value:: dc
      real(f), intent(in):: mingridx(dim), x(dim, n)
      integer, intent(in):: ncells(dim)
      integer, intent(out):: gridCellHash(:)
      integer:: d, i, ip, icell(dim)
      integer, value:: n
     
      i = blockDim%x * (blockIdx%x - 1) + threadIdx%x
      if (i <= n) then
        icell(:) = int((x(:,i) - mingridx(:))/dc) + 1
        gridCellHash(i) = cells2Hash(icell, ncells)
      end if
     
   end subroutine map2Grid
   
   !==============================================================================================================================
   attributes(global) subroutine sweep(x, itype, maxint, sk, ngx, np, gridCellHash, cellLoc, nij, pij)

      implicit none
      integer, intent(in), value:: np, maxint
      real(f), intent(in), value:: sk
      real(f), intent(in):: x(dim, np)
      integer, intent(in):: gridCellHash(np), cellLoc(:,:), ngx(dim), itype(np)
      integer, intent(inout):: nij
      type(interactions), intent(out):: pij(maxint)
      integer:: i, j, k, d, icell(dim), jcell(dim), hashAdj, niji, tmp
      real(f):: x_i(dim)
      integer, parameter:: sweepinds(3, 13) = reshape((/-1,-1,-1, &
                                                         0,-1,-1, &
                                                         1,-1,-1, &
                                                        -1, 0,-1, &
                                                         0, 0,-1, &
                                                         1, 0,-1, &
                                                        -1, 1,-1, &
                                                         0, 1,-1, &
                                                         1, 1,-1, &
                                                        -1,-1, 0, &
                                                         0,-1, 0, &
                                                         1,-1, 0, &
                                                        -1, 0, 0/) , (/3, 13/))

      i = blockDim%x*(blockIdx%x - 1) + threadIdx%x

      ! Beginning sweep
      if (i <= np) then
         do j = i+1, cellLoc(2,gridCellHash(i))
            call check_if_interact(maxint, sk, i, j, itype(i), itype(j), x(:,i), x(:,j), nij, pij(:))
         end do
         icell = hash2Cell(gridCellHash(i), ngx)
         do k = 1, 13
            jcell = icell(:) + sweepinds(:,k)
            hashAdj = cells2Hash(jcell, ngx)
            do j = cellLoc(1,hashAdj), cellLoc(2,hashAdj)
               call check_if_interact(maxint, sk, i, j, itype(i), itype(j), x(:,i), x(:,j), nij, pij(:))
            end do
         end do
         if (nij==maxint) write(*,*) '***ERROR*** Particle ',i,' has exceeded max interactions per particle' !tmp = atomicexch(ierr,1)
      end if

   end subroutine sweep

   !==============================================================================================================================
   attributes(device) subroutine check_if_interact(maxint, sk, i, j, itypei, itypej, xi, xj, nij, pij)
      ! subroutine to chekc if two particles are interacting and consequently adding to pair list

      implicit none
      integer, intent(in):: maxint, i, j, itypei, itypej
      real(f), intent(in):: sk, xi(dim), xj(dim)
      integer, intent(inout):: nij
      type(interactions), intent(inout):: pij(maxint)
      integer:: tmp
      real(f):: dxiac(dim), r

      ! only consider interactions when real particles are involved
      if (itypei == 1 .or. itypej == 1) then
         
         dxiac(:) = xi(:) - xj(:)
         r = SQRT(SUM(dxiac*dxiac))
         if (r < (1._f+skin)*hsml*sk) then
            tmp = atomicadd(nij,1) + 1
            pij(tmp)%i = i
            pij(tmp)%j = j
            call kernel(r, dxiac(:), hsml, pij(tmp)%w, pij(tmp)%dwdx(:))
         end if
      end if

   end subroutine check_if_interact

   !==============================================================================================================================
   attributes(device) pure subroutine kernel(r, dx, thsml, tw, tdwdx)
      ! Contains the kernels

      use param, only: skf, pi, dims => dim

      implicit none
      real(f), intent(in):: dx(dims), r, thsml
      real(f), intent(out):: tdwdx(dims), tw
      real(f):: q, factor

      q = r/thsml

      SELECT CASE (SKF)
      CASE (1) ! cubic
         if (dims == 2) factor = 10._f/(7._f*pi*thsml*thsml)
         if (dims == 3) factor = 1_f/(pi*thsml*thsml*thsml)
         tw = factor*(0.25_f*MAX(0._f, 2._f - q)**3 - MAX(0._f, 1._f - q)**3)
         tdwdx = -factor*3._f*(0.25_f*MAX(0._f, 2._f - q)**2 - MAX(0._f, 1._f - q)**2)*dx(:)/(r*thsml)
      CASE (2) ! quartic
         if (dims == 2) factor = 96_f/(1199_f*pi*thsml*thsml)
         if (dims == 3) factor = 1_f/(20_f*pi*thsml*thsml*thsml)
         tw = factor*(MAX(0._f, 2.5_f - q)**4 - 5_f*MAX(0._f, 1.5_f - q)**4 + 10_f*MAX(0._f, 0.5_f - q)**4)
         tdwdx(:) = &
            -factor*4._f*(MAX(0._f, 2.5_f - q)**3 - 5_f*MAX(0._f, 1.5_f - q)**3 + 10_f*MAX(0._f, 0.5_f - q)**3)*dx(:)/(r*thsml)
      CASE (3) ! quintic
         if (dims == 2) factor = 7_f/(478_f*pi*thsml*thsml)
         if (dims == 3) factor = 1_f/(120_f*pi*thsml*thsml*thsml)
         tw = factor*(MAX(0._f, 3._f - q)**5 - 6._f*MAX(0._f, 2._f - q)**5 + 15._f*MAX(0._f, 1._f - q)**5)
         tdwdx(:) = &
            -factor*5._f*(MAX(0._f, 3._f - q)**4 - 6._f*MAX(0._f, 2._f - q)**4 + 15._f*MAX(0._f, 1._f - q)**4)*dx(:)/(r*thsml)
      CASE (4) ! Wenland Quintic C2
         if (dims == 2) factor = 7._f/(64._f*pi*thsml*thsml)
         if (dims == 3) factor = 21._f/(256._f*pi*thsml*thsml*thsml)
         tw = factor*MAX(0._f, 2._f - q)**4*(2._f*q + 1._f)
         tdwdx(:) = -factor*10._f*q*MAX(0._f, 2._f - q)**3*dx(:)/(r*thsml)
      CASE (5) ! Wenland Quintic C4
         if (dims == 2) factor = 3._f/(1024._f*pi*thsml*thsml)
         if (dims == 3) factor = 165._f/(65536._f*pi*thsml*thsml*thsml)
         tw = factor*MAX(0._f, 2._f - q)**6*(35._f*q**2 + 36._f*q + 12._f)
         tdwdx(:) = -factor*56._f*q*MAX(0._f, 2._f - q)**5*(5._f*q + 2._f)*dx(:)/(r*thsml)
      CASE (6) ! Wenland Quintic C6
         if (dims == 2) factor = 39._f/(14336._f*pi*thsml*thsml)
         if (dims == 3) factor = 1365._f/(524288._f*pi*thsml*thsml*thsml)
         tw = factor*MAX(0._f, 2._f - q)**8*(16._f*q**3 + 25_f*q**2 + 16._f*q + 4._f)
         tdwdx(:) = -factor*22._f*q*(8._f*q**2 + 7._f*q + 2._f)*MAX(0._f, 2._f - q)**7*dx(:)/(r*thsml)
      CASE (7) ! gaussian
         factor = 1_f/(thsml**dims*pi**(0.5_f*dims))
         if (q .ge. 0_f .and. q .le. 3_f) then
            tw = factor*exp(-q*q)
            tdwdx(:) = tw*2._f*dx(:)/(thsml*thsml)
         end if

      END SELECT

   end subroutine kernel

   !==============================================================================================================================
   function kernel_k(skf) result(scale_k)
      ! setting k parameter for kernel radius (r = kh)

      implicit none
      integer, intent(in):: skf
      integer:: scale_k

      select case (skf)
      case default ! cubic, wenland C2, wenland C4, wenland C6
         scale_k = 2._f
      case (2) ! quartic
         scale_k = 2.5_f
      case (3) ! quantic
         scale_k = 3._f
      case (7)
         scale_k = huge(1._f)
      end select

   end function kernel_k
   
   !=================================================================================================================================
   attributes(device) pure function cells2Hash(cellCoords, ncells) result(hash)
     
      implicit none
      integer, intent(in):: cellCoords(dim), ncells(dim)
      integer:: hash
     
      hash = ncells(1)*ncells(2)*(cellCoords(3) - 1) + ncells(1)*(cellCoords(2) - 1) + cellCoords(1)
     
   end function cells2Hash
   
   !=================================================================================================================================
   attributes(device) pure function hash2Cell(hash, ncells) result(cellCoords)
   
      implicit none
      integer, intent(in):: hash, ncells(dim)
      integer:: cellCoords(3), nxy, modhashnxy
     
      nxy = ncells(1)*ncells(2)
      modhashnxy = mod(hash-1,nxy)
     
      cellCoords(3) = int((hash-1)/nxy) + 1
      cellCoords(2) = mod(hash-1,nxy)/ncells(1) + 1
      cellCoords(1) = mod(modhashnxy,ncells(1)) + 1
     
   end function hash2Cell

   attributes(global) subroutine update_wdwdx(hsml, np, niac, x, pairs)

      implicit none
      real(f), intent(in), value:: hsml
      integer, intent(in), value:: np
      integer, intent(in):: niac
      real(f), intent(in):: x(dim, np)
      type(interactions), intent(inout):: pairs(niac)
      integer:: i,j,k
      real(f):: dx(dim), r

      k = blockDim%x*(blockIdx%x - 1) + threadIdx%x
      if (k <= niac) then
         dx = x(:,pairs(k)%i) - x(:,pairs(k)%j)
         r = sqrt(sum(dx*dx))
         call kernel(r, dx, hsml, pairs(k)%w, pairs(k)%dwdx)
      end if

   end subroutine update_wdwdx

end module flink_list_m

