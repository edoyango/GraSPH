module input_m
	
    use datatypes, only: particles,interactions
	use globvar, only: parts,ntotal,nvirt,maxinter_perp,scale_k_d
	use param, only: dim,f,dxo,mp,np,op,pp,qp,rp,nlayer,irho,g,gamma,c,hsml,mass
	
	use output_m, only: write_ini_config
    
    real(f),parameter:: vxmin = 0._f, vymin = 0._f, vzmin = 0._f, &
        vxmax = vxmin + pp*dxo, vymax = vymin + qp*dxo, vzmax = vzmin + rp*dxo
    real(f),parameter:: rxmin = 0._f, rymin = 0._f, rzmin = 0._f, &
        rxmax = rxmin + mp*dxo, rymax = rymin + np*dxo, rzmax = rzmin + op*dxo
	
	public:: input,virt_part
	private:: input2D,input3D,virt_part2D,virt_part3D
	
contains
	
	!==============================================================================================================================
	subroutine input(generate)
	! interface subroutine for initial particle config in the 2D and 3D case
	
		implicit none
		logical,intent(in):: generate
	
		select case (dim)
			case(2)
				call input2D(generate)
			case(3)
				call input3D(generate)
		end select
	
	end subroutine input
	
	!==============================================================================================================================
	subroutine virt_part(generate)
	! interface subroutine for virtual particle config in the 2D and 3D case
	
		implicit none
		logical,intent(in):: generate
		
		select case (dim)
			case(2)
				call virt_part2D(generate)
			case(3)
				call virt_part3D(generate)
		end select
		
	end subroutine virt_part

	!==============================================================================================================================
	subroutine input2D(generate)
	
		implicit none
		logical,intent(in):: generate
		integer:: i,j,d,n
		real(f):: xi,yi
		
		select case (generate)
		
			case (.false.)
				
				ntotal = mp*op
				
			case (.true.)
			
				n = 0
				do i = 1, mp
					do j = 1, op
						n = n + 1
						parts(n)%ind = n
						parts(n)%x(1) = (i-0.5_f)*dxo
						parts(n)%x(2) = (j-0.5_f)*dxo
						parts(n)%vx(:) = 0_f
						parts(n)%itype = 1
						parts(n)%rho = irho
						parts(n)%p = 0_f
					enddo
				enddo
				
				call write_ini_config
			
		end select
	
	end subroutine input2D
	
	!==============================================================================================================================
	subroutine input3D(generate)
	
		implicit none
		logical,intent(in):: generate
		integer:: i,j,k,d,n
		real(f):: xi,yi,zi
		
		select case (generate)
		
			case (.false.)
				
				ntotal = mp*np*op
				
			case (.true.)
			
				n = 0
				do i = 1, mp
					do j = 1, np
						do k = 1,op
							n = n + 1
							parts(n)%ind = n
							parts(n)%x(1) = (i-0.5_f)*dxo
							parts(n)%x(2) = (j-0.5_f)*dxo
							parts(n)%x(3) = (k-0.5_f)*dxo
							parts(n)%vx(:) = 0._f
							parts(n)%itype = 1
                            parts(n)%p = 0._f!(zl-parts(n)%x(3))*g*irho
							parts(n)%rho = irho*(parts(n)%p*gamma/(c**2*irho)+1)**(1._f/gamma)
							
						end do
					end do
				end do
				
				call write_ini_config
			
		end select
	
	end subroutine input3D
	
	!==============================================================================================================================
	subroutine virt_part2D(generate)
		
		implicit none
		logical,intent(in):: generate
		integer:: i,j,k,d,n
		
		select case (generate)
			
			case (.false.)
				
				nvirt = 2*pp + 2*rp
				
			case (.true.)
				
				n = ntotal
				
				!---Virtual particle on the lower boundary
				do i = 1, pp
					n = n + 1
					parts(n)%ind = n
					parts(n)%x(1) = vxmin + (i-0.5_f)*dxo
					parts(n)%x(2) = vymin - 0.5_f*dxo
					parts(n)%vx(:) = 0_f
				enddo
				
				!---Virtual particle on the upper boundary
				do i = 1, pp
					n = n + 1
					parts(n)%ind = n
					parts(n)%x(1) = vxmin + (i-0.5_f)*dxo
					parts(n)%x(2) = vymax - 1.5_f*dxo
					parts(n)%vx(:) = 0_f
				enddo
				
				!---Virtual particle on the left boundary
				do i = 1, rp
					n = n + 1
					parts(n)%ind = n
					parts(n)%x(1) = vxmin - 0.5_f*dxo
					parts(n)%x(2) = vymin + (i-1.5_f)*dxo
					parts(n)%vx(:) = 0_f
				enddo
				
				!---Virtual particle on the right boundary
				do i = 1, rp
					n = n + 1
					parts(n)%ind = n
					parts(n)%x(1) = vxmax + 0.5_f*dxo
					parts(n)%x(2) = vymin + (i-1.5_f)*dxo
					parts(n)%vx(:) = 0_f
				enddo
	
				parts(ntotal+1:ntotal+nvirt)%rho = irho
				parts(ntotal+1:ntotal+nvirt)%p = 0_f
				parts(ntotal+1:ntotal+nvirt)%itype = -1
				
		end select
	
	end subroutine virt_part2D
	
	!==============================================================================================================================
	subroutine virt_part3D(generate)
		
		implicit none
		logical,intent(in):: generate
		integer:: i,j,k,d,n
		
		select case (generate)
			
			case (.false.)
				
				nvirt = (pp+2*nlayer)*(qp+2*nlayer)*nlayer
				
			case (.true.)
				
				n = ntotal
				
				do i = 1-nlayer,pp+nlayer
                    do j = 1-nlayer,qp+nlayer
                        do k = 1-nlayer,rp+nlayer
                            if ( k<1 ) then
                                n = n + 1
                                parts(n)%ind = n
                                parts(n)%x(1) = vxmin + (i-0.5_f)*dxo
                                parts(n)%x(2) = vymin + (j-0.5_f)*dxo
                                parts(n)%x(3) = vzmin + (k-0.5_f)*dxo
                                parts(n)%vx(:) = 0._f
                                parts(n)%rho = irho
                                parts(n)%p = 0._f
                                parts(n)%itype = -1
                            end if
                        end do
                    end do
                end do
                
		end select
	
	end subroutine virt_part3D
    
    !===============================================================================================================================
    attributes(global) subroutine generate_ghost_part(nt,nv,ng,pts,gind)
    
        implicit none
        integer,intent(in):: nt,nv
        integer,intent(inout):: ng
        type(particles),intent(inout):: pts(2*nt+nv)
        integer,intent(out):: gind(nt)
        integer:: i,j,k,d,tmpi
        
        i = blockDim%x*(blockIdx%x-1)+threadIdx%x
        
        if (i<=nt) then
            if (abs(pts(i)%x(1)-vxmin) < hsml*scale_k_d) then
                tmpi = atomicadd(ng,1)
                pts(nt+nv+tmpi+1) = pts(i)
                gind(tmpi+1) = pts(i)%ind
                pts(nt+nv+tmpi+1)%itype = 2
                pts(nt+nv+tmpi+1)%ind = nt+nv+tmpi+1
                pts(nt+nv+tmpi+1)%x(1) = -pts(nt+nv+tmpi+1)%x(1) + 2._f*vxmin
                pts(nt+nv+tmpi+1)%vx(1) = -pts(nt+nv+tmpi+1)%vx(1)
            end if
            if (abs(pts(i)%x(1)-vxmax) < hsml*scale_k_d) then
                tmpi = atomicadd(ng,1)
                pts(nt+nv+tmpi+1) = pts(i)
                gind(tmpi+1) = pts(i)%ind
                pts(nt+nv+tmpi+1)%itype = 2
                pts(nt+nv+tmpi+1)%ind = nt+nv+tmpi+1
                pts(nt+nv+tmpi+1)%x(1) = -pts(nt+nv+tmpi+1)%x(1) + 2._f*vxmax
                pts(nt+nv+tmpi+1)%vx(1) = -pts(nt+nv+tmpi+1)%vx(1)
            end if
            if (abs(pts(i)%x(2)-vymin) < hsml*scale_k_d) then
                tmpi = atomicadd(ng,1)
                pts(nt+nv+tmpi+1) = pts(i)
                gind(tmpi+1) = pts(i)%ind
                pts(nt+nv+tmpi+1)%itype = 3
                pts(nt+nv+tmpi+1)%ind = nt+nv+tmpi+1
                pts(nt+nv+tmpi+1)%x(2) = -pts(nt+nv+tmpi+1)%x(2) + 2._f*vymin
                pts(nt+nv+tmpi+1)%vx(2) = -pts(nt+nv+tmpi+1)%vx(2)
            end if
            if (abs(pts(i)%x(2)-vymax) < hsml*scale_k_d) then
                tmpi = atomicadd(ng,1)
                pts(nt+nv+tmpi+1) = pts(i)
                gind(tmpi+1) = pts(i)%ind
                pts(nt+nv+tmpi+1)%ind = nt+nv+tmpi+1
                pts(nt+nv+tmpi+1)%itype = 3
                pts(nt+nv+tmpi+1)%x(2) = -pts(nt+nv+tmpi+1)%x(2) + 2._f*vymax
                pts(nt+nv+tmpi+1)%vx(2) = -pts(nt+nv+tmpi+1)%vx(2) 
            end if
            if ( (pts(i)%x(1)-vxmin)**2 + (pts(i)%x(2)-vymin)**2 < (hsml*scale_k_d)**2 ) then
                tmpi = atomicadd(ng,1)
                pts(nt+nv+tmpi+1) = pts(i)
                gind(tmpi+1) = pts(i)%ind
                pts(nt+nv+tmpi+1)%itype = 5
                pts(nt+nv+tmpi+1)%ind = nt+nv+tmpi+1
                pts(nt+nv+tmpi+1)%x(1) = -pts(nt+nv+tmpi+1)%x(1) + 2._f*vxmin
                pts(nt+nv+tmpi+1)%x(2) = -pts(nt+nv+tmpi+1)%x(2) + 2._f*vymin
                pts(nt+nv+tmpi+1)%vx(1) = -pts(nt+nv+tmpi+1)%vx(1)
                pts(nt+nv+tmpi+1)%vx(2) = -pts(nt+nv+tmpi+1)%vx(2)
            end if
            if ( (pts(i)%x(1)-vxmin)**2 + (pts(i)%x(2)-vymax)**2 < (hsml*scale_k_d)**2 ) then
                tmpi = atomicadd(ng,1)
                pts(nt+nv+tmpi+1) = pts(i)
                gind(tmpi+1) = pts(i)%ind
                pts(nt+nv+tmpi+1)%itype = 5
                pts(nt+nv+tmpi+1)%ind = nt+nv+tmpi+1
                pts(nt+nv+tmpi+1)%x(1) = -pts(nt+nv+tmpi+1)%x(1) + 2._f*vxmin
                pts(nt+nv+tmpi+1)%x(2) = -pts(nt+nv+tmpi+1)%x(2) + 2._f*vymax
                pts(nt+nv+tmpi+1)%vx(1) = -pts(nt+nv+tmpi+1)%vx(1)
                pts(nt+nv+tmpi+1)%vx(2) = -pts(nt+nv+tmpi+1)%vx(2)
            end if
            if ( (pts(i)%x(1)-vxmax)**2 + (pts(i)%x(2)-vymin)**2 < (hsml*scale_k_d)**2 ) then
                tmpi = atomicadd(ng,1)
                pts(nt+nv+tmpi+1) = pts(i)
                gind(tmpi+1) = pts(i)%ind
                pts(nt+nv+tmpi+1)%itype = 5
                pts(nt+nv+tmpi+1)%ind = nt+nv+tmpi+1
                pts(nt+nv+tmpi+1)%x(1) = -pts(nt+nv+tmpi+1)%x(1) + 2._f*vxmax
                pts(nt+nv+tmpi+1)%x(2) = -pts(nt+nv+tmpi+1)%x(2) + 2._f*vymin
                pts(nt+nv+tmpi+1)%vx(1) = -pts(nt+nv+tmpi+1)%vx(1)
                pts(nt+nv+tmpi+1)%vx(2) = -pts(nt+nv+tmpi+1)%vx(2)
            end if
            if ( (pts(i)%x(1)-vxmax)**2 + (pts(i)%x(2)-vymax)**2 < (hsml*scale_k_d)**2 ) then
                tmpi = atomicadd(ng,1)
                pts(nt+nv+tmpi+1) = pts(i)
                gind(tmpi+1) = pts(i)%ind
                pts(nt+nv+tmpi+1)%itype = 5
                pts(nt+nv+tmpi+1)%ind = nt+nv+tmpi+1
                pts(nt+nv+tmpi+1)%x(1) = -pts(nt+nv+tmpi+1)%x(1) + 2._f*vxmax
                pts(nt+nv+tmpi+1)%x(2) = -pts(nt+nv+tmpi+1)%x(2) + 2._f*vymax
                pts(nt+nv+tmpi+1)%vx(1) = -pts(nt+nv+tmpi+1)%vx(1)
                pts(nt+nv+tmpi+1)%vx(2) = -pts(nt+nv+tmpi+1)%vx(2)
            end if
            
        end if
        
    end subroutine generate_ghost_part
    
    !===============================================================================================================================
    attributes(global) subroutine update_ghost_part(nt,nv,ng,pts,gind)
    
        implicit none
        integer,intent(in):: nt,nv,ng,gind(ng)
        type(particles),intent(inout):: pts(nt+nv+ng)
        integer:: i,j,k,d
        
        i = blockDim%x*(blockIdx%x-1)+threadIdx%x
        
        if (i<=ng) then
            j = gind(i)
            pts(nt+nv+i)%rho = pts(j)%rho
            pts(nt+nv+i)%p = pts(j)%p
            select case (pts(nt+nv+i)%itype)
                case (2)
                    pts(nt+nv+i)%vx(1) = -pts(j)%vx(1)
                    pts(nt+nv+i)%vx(2) =  pts(j)%vx(2)
                    pts(nt+nv+i)%vx(3) =  pts(j)%vx(3)
                case (3)
                    pts(nt+nv+i)%vx(1) =  pts(j)%vx(1)
                    pts(nt+nv+i)%vx(2) = -pts(j)%vx(2)
                    pts(nt+nv+i)%vx(3) =  pts(j)%vx(3)
                case (4)
                    pts(nt+nv+i)%vx(1) =  pts(j)%vx(1)
                    pts(nt+nv+i)%vx(2) =  pts(j)%vx(2)
                    pts(nt+nv+i)%vx(3) = -pts(j)%vx(3)
                case (5)
                    pts(nt+nv+i)%vx(1) = -pts(j)%vx(1)
                    pts(nt+nv+i)%vx(2) = -pts(j)%vx(2)
                    pts(nt+nv+i)%vx(3) =  pts(j)%vx(3)
            end select
        end if
    
    end subroutine update_ghost_part
    
    !===============================================================================================================================
    attributes(global) subroutine vmat_update(nt,nv,ng,nij,pij,vw)
    
        implicit none
        integer,intent(in):: nt,nv,ng,nij(nt+nv+ng)
        type(interactions),intent(in):: pij(maxinter_perp,nt+nv+ng)
        real(f),intent(inout):: vw(nv)
        integer:: i,j,k,d
        real(f):: tmp,tmp2
        
        i = blockDim%x*(blockIdx%x-1)+threadIdx%x
        
        if (i<=nt+nv+ng) then
            do k = 1,nij(i)
                if (pij(k,i)%i%itype < 0 .and. pij(k,i)%j%itype > 0) then
                    tmp = mass*pij(k,i)%w/pij(k,i)%j%rho
                    tmp2 = atomicadd(vw(pij(k,i)%i%ind-nt),tmp)
                    tmp2 = atomicadd(pij(k,i)%i%rho,mass*pij(k,i)%w)
                    select case (pij(k,i)%i%itype)
                        case(-1) ! top-bottom walls
                            tmp2 = atomicadd(pij(k,i)%i%vx(1),-pij(k,i)%j%vx(1)*tmp)
                            tmp2 = atomicadd(pij(k,i)%i%vx(2),-pij(k,i)%j%vx(2)*tmp)
                            tmp2 = atomicadd(pij(k,i)%i%vx(3),-pij(k,i)%j%vx(3)*tmp)
                        case(-2) ! north-south walls
                            tmp2 = atomicadd(pij(k,i)%i%vx(1), pij(k,i)%j%vx(1)*tmp)
                            tmp2 = atomicadd(pij(k,i)%i%vx(2),-pij(k,i)%j%vx(2)*tmp)
                            tmp2 = atomicadd(pij(k,i)%i%vx(3), pij(k,i)%j%vx(3)*tmp)
                        case(-3) ! east-west walls
                            tmp2 = atomicadd(pij(k,i)%i%vx(1),-pij(k,i)%j%vx(1)*tmp)
                            tmp2 = atomicadd(pij(k,i)%i%vx(2), pij(k,i)%j%vx(2)*tmp)
                            tmp2 = atomicadd(pij(k,i)%i%vx(3), pij(k,i)%j%vx(3)*tmp)
                    end select
                else if (pij(k,i)%j%itype < 0 .and. pij(k,i)%i%itype > 0) then
                    tmp = mass*pij(k,i)%w/pij(k,i)%i%rho
                    tmp2 = atomicadd(vw(pij(k,i)%j%ind-nt),tmp)
                    tmp2 = atomicadd(pij(k,i)%j%rho,mass*pij(k,i)%w)
                    select case (pij(k,i)%j%itype)
                        case(-1) ! top-bottom walls
                            tmp2 = atomicadd(pij(k,i)%j%vx(1),-pij(k,i)%i%vx(1)*tmp)
                            tmp2 = atomicadd(pij(k,i)%j%vx(2),-pij(k,i)%i%vx(2)*tmp)
                            tmp2 = atomicadd(pij(k,i)%j%vx(3),-pij(k,i)%i%vx(3)*tmp)
                        case(-2) ! north-south walls
                            tmp2 = atomicadd(pij(k,i)%j%vx(1), pij(k,i)%i%vx(1)*tmp)
                            tmp2 = atomicadd(pij(k,i)%j%vx(2),-pij(k,i)%i%vx(2)*tmp)
                            tmp2 = atomicadd(pij(k,i)%j%vx(3), pij(k,i)%i%vx(3)*tmp)
                        case(-3) ! east-west walls
                            tmp2 = atomicadd(pij(k,i)%j%vx(1),-pij(k,i)%i%vx(1)*tmp)
                            tmp2 = atomicadd(pij(k,i)%j%vx(2), pij(k,i)%i%vx(2)*tmp)
                            tmp2 = atomicadd(pij(k,i)%j%vx(3), pij(k,i)%i%vx(3)*tmp)
                    end select
                end if
            end do
        end if
        
    end subroutine vmat_update

end module input_m
