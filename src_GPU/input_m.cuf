module input_m

   use datatypes, only: particles, interactions
   use param, only: dim, f, dxo, mp, np, op, pp, qp, rp, nlayer, irho, g, gamma, c, hsml, mass

   private
   real(f), parameter, public:: vxmin = 0._f, vymin = 0._f, vzmin = 0._f, &
                                vxmax = vxmin + pp*dxo, vymax = vymin + qp*dxo, vzmax = vzmin + rp*dxo
   real(f), parameter, public:: rxmin = 0._f, rymin = 0._f, rzmin = 0._f, &
                                rxmax = rxmin + mp*dxo, rymax = rymin + np*dxo, rzmax = rzmin + op*dxo

   public:: return_ntotal, return_nvirt, allocatePersistentArrays, generate_real_part, generate_virt_part, &
            generate_ghost_part, update_ghost_part

contains

   !==============================================================================================================================
   pure function return_ntotal() result(ntotal)

      implicit none
      integer:: ntotal

      ntotal = mp*np*op

   end function return_ntotal

   !==============================================================================================================================
   pure function return_nvirt() result(nvirt)

      implicit none
      integer:: nvirt, i, j, k
      
      nvirt = 0
      do i = 1 - nlayer, pp + nlayer
         do j = 1 - nlayer, qp + nlayer
            do k = 1 - nlayer, rp + nlayer
               if (.not.(i>=1 .and. i<=pp .and. j>=1 .and. j<=qp .and. k>=1 .and. k<=rp)) then
                  nvirt = nvirt + 1
               end if
            end do
         end do
      end do

   end function return_nvirt

   !==============================================================================================================================
   subroutine allocatePersistentArrays(ntotal, nvirt, maxn, maxinter_perp, maxinter, pairs, pairs_d, itype, ind, itype_d, &
   ind_d, p, rho, x, vx, p_d, rho_d, x_d, vx_d)

      implicit none
      integer, intent(in):: ntotal, nvirt, maxinter_perp
      integer, intent(out):: maxn, maxinter
      integer, allocatable, intent(inout):: itype(:), ind(:)
      integer, allocatable, device, intent(inout):: itype_d(:), ind_d(:)
      real(f), allocatable, intent(inout):: p(:), rho(:), x(:,:), vx(:,:)
      real(f), allocatable, device, intent(inout):: p_d(:), rho_d(:), x_d(:,:), vx_d(:,:)
      type(interactions), allocatable, intent(inout):: pairs(:)
      type(interactions), allocatable, intent(inout), device:: pairs_d(:)

      maxn = ntotal + nvirt!+int(0.2*ntotal)
      maxinter = maxinter_perp*maxn
      allocate( itype(maxn), ind(maxn), p(maxn), rho(maxn), x(dim,maxn), vx(dim,maxn))
      allocate(itype_d(maxn), ind_d(maxn), p_d(maxn), rho_d(maxn), x_d(dim,maxn), vx_d(dim,maxn))
      allocate (pairs(maxinter), pairs_d(maxinter))

   end subroutine allocatePersistentArrays

   !==============================================================================================================================
   subroutine generate_real_part(ntotal, itype, ind, p, rho, x, vx)

      implicit none
      integer, intent(in):: ntotal
      integer, intent(out):: itype(ntotal), ind(ntotal)
      real(f), intent(out):: p(ntotal), rho(ntotal), x(dim,ntotal), vx(dim,ntotal)
      integer:: i, j, k, d, n
      real(f):: xi, yi, zi

      n = 0
      do i = 1, mp
         do j = 1, np
            do k = 1, op
               n = n + 1
               itype(n) = 1
               ind(n) = n
               p(n) = 0._f
               rho(n) = irho*(p(n)*gamma/(c**2*irho) + 1)**(1._f/gamma)
               x(1,n) = (i - 0.5_f)*dxo
               x(2,n) = (j - 0.5_f)*dxo
               x(3,n) = (k - 0.5_f)*dxo
               vx(:,n) = 0._f
            end do
         end do
      end do

   end subroutine generate_real_part

   !==============================================================================================================================
   subroutine generate_virt_part(ntotal, nvirt, itype, ind, p, rho, x, vx)

      implicit none
      integer, intent(in):: ntotal, nvirt
      integer, intent(out):: itype(ntotal+nvirt), ind(ntotal+nvirt)
      real(f), intent(out):: p(ntotal+nvirt), rho(ntotal+nvirt), x(dim,ntotal+nvirt), vx(dim,ntotal+nvirt)
      integer:: i, j, k, d, n

      n = ntotal

      do i = 1 - nlayer, pp + nlayer
         do j = 1 - nlayer, qp + nlayer
            do k = 1 - nlayer, rp + nlayer
               if (.not.(i>=1 .and. i<=pp .and. j>=1 .and. j<=qp .and. k>=1 .and. k<=rp)) then
                  n = n + 1
                  if (k < 1) then
                     itype(n) = -1
                  else if (k > rp) then
                     itype(n) = -2
                  else if (i < 1) then
                     itype(n) = -3
                  else if (i>pp) then
                     itype(n) = -4
                  else if (j < 1) then
                     itype(n) = -5
                  else if (j > qp) then
                     itype(n) = -6
                  end if
                  ind(n) = n
                  p(n) = 0._f
                  rho(n) = irho
                  x(1,n) = vxmin + (i - 0.5_f)*dxo
                  x(2,n) = vymin + (j - 0.5_f)*dxo
                  x(3,n) = vzmin + (k - 0.5_f)*dxo
                  vx(:,n) = 0._f
               end if
            end do
         end do
      end do

   end subroutine generate_virt_part

   !===============================================================================================================================
   attributes(global) subroutine vmat_update(maxinter, n_p, nij, pij, vw, itype, rho, vx)

      implicit none
      integer, intent(in), value:: maxinter, n_p
      integer, intent(in):: nij, itype(n_p)
      real(f), intent(in):: rho(n_p), vx(dim, n_p)
      type(interactions), intent(in):: pij(maxinter)
      real(f), intent(inout):: vw(n_p)
      integer:: i, j, k, d
      real(f):: tmp, tmp2

      k = blockDim%x*(blockIdx%x - 1) + threadIdx%x

      if (k <= nij) then
         i = pij(k)%i
         j = pij(k)%j
            if (itype(i) < 0 .and. itype(j) > 0) then
               tmp = mass*pij(k)%w/rho(j)
               tmp2 = atomicadd(vw(i), tmp)
               tmp2 = atomicadd(rho(i), mass*pij(k)%w)
               select case (itype(i))
               case (-1, 2) ! top-bottom walls
                  tmp2 = atomicadd(vx(1,i), -vx(1,j)*tmp)
                  tmp2 = atomicadd(vx(2,i), -vx(2,j)*tmp)
                  tmp2 = atomicadd(vx(3,i), -vx(3,j)*tmp)
               case (-5, -6) ! north-south walls
                  tmp2 = atomicadd(vx(1,i), vx(1,j)*tmp)
                  tmp2 = atomicadd(vx(2,i),-vx(2,j)*tmp)
                  tmp2 = atomicadd(vx(3,i), vx(3,j)*tmp)
               case (-3, -4) ! east-west walls
                  tmp2 = atomicadd(vx(1,i),-vx(1,j)*tmp)
                  tmp2 = atomicadd(vx(2,i), vx(2,j)*tmp)
                  tmp2 = atomicadd(vx(3,i), vx(3,j)*tmp)
               end select
            else if (itype(j) < 0 .and. itype(i) > 0) then
               tmp = mass*pij(k)%w/rho(i)
               tmp2 = atomicadd(vw(j), tmp)
               tmp2 = atomicadd(rho(j), mass*pij(k)%w)
               select case (itype(j))
               case (-1, 2) ! top-bottom walls
                  tmp2 = atomicadd(vx(1,j), -vx(1,i)*tmp)
                  tmp2 = atomicadd(vx(2,j), -vx(2,i)*tmp)
                  tmp2 = atomicadd(vx(3,j), -vx(3,i)*tmp)
               case (-5, -6) ! north-south walls
                  tmp2 = atomicadd(vx(1,j), vx(1,i)*tmp)
                  tmp2 = atomicadd(vx(2,j),-vx(2,i)*tmp)
                  tmp2 = atomicadd(vx(3,j), vx(3,i)*tmp)
               case (-3, -4) ! east-west walls
                  tmp2 = atomicadd(vx(1,j),-vx(1,i)*tmp)
                  tmp2 = atomicadd(vx(2,j), vx(2,i)*tmp)
                  tmp2 = atomicadd(vx(3,j), vx(3,i)*tmp)
               end select
            end if
      end if

   end subroutine vmat_update

end module input_m
