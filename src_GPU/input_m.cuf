module input_m

   use datatypes, only: particles, interactions
   use param, only: dim, f, dxo, mp, np, op, pp, qp, rp, nlayer, irho, g, gamma, c, hsml, mass

   private
   real(f), parameter, public:: vxmin = 0._f, vymin = 0._f, vzmin = 0._f, &
                                vxmax = vxmin + pp*dxo, vymax = vymin + qp*dxo, vzmax = vzmin + rp*dxo
   real(f), parameter, public:: rxmin = 0._f, rymin = 0._f, rzmin = 0._f, &
                                rxmax = rxmin + mp*dxo, rymax = rymin + np*dxo, rzmax = rzmin + op*dxo

   public:: return_ntotal, return_nvirt, allocatePersistentArrays, generate_real_part, generate_virt_part, &
            generate_ghost_part, update_ghost_part

contains

   !==============================================================================================================================
   pure function return_ntotal() result(ntotal)

      implicit none
      integer:: ntotal

      ntotal = mp*np*op

   end function return_ntotal

   !==============================================================================================================================
   pure function return_nvirt() result(nvirt)

      implicit none
      integer:: nvirt, i, j, k
      
      nvirt = 0
      do i = 1 - nlayer, pp + nlayer
         do j = 1 - nlayer, qp + nlayer
            do k = 1 - nlayer, rp + nlayer
               if (.not.(i>=1 .and. i<=pp .and. j>=1 .and. j<=qp .and. k>=1 .and. k<=rp)) then
                  nvirt = nvirt + 1
               end if
            end do
         end do
      end do

   end function return_nvirt

   !==============================================================================================================================
   subroutine allocatePersistentArrays(ntotal, nvirt, maxn, maxinter_perp, maxinter, pairs, pairs_d, itype, ind, itype_d, &
   ind_d, p, rho, x, vx, p_d, rho_d, x_d, vx_d)

      implicit none
      integer, intent(in):: ntotal, nvirt, maxinter_perp
      integer, intent(out):: maxn, maxinter
      integer, allocatable, intent(inout):: itype(:), ind(:)
      integer, allocatable, device, intent(inout):: itype_d(:), ind_d(:)
      real(f), allocatable, intent(inout):: p(:), rho(:), x(:,:), vx(:,:)
      real(f), allocatable, device, intent(inout):: p_d(:), rho_d(:), x_d(:,:), vx_d(:,:)
      type(interactions), allocatable, intent(inout):: pairs(:)
      type(interactions), allocatable, intent(inout), device:: pairs_d(:)

      maxn = ntotal + nvirt!+int(0.2*ntotal)
      maxinter = maxinter_perp*maxn
      allocate( itype(maxn), ind(maxn), p(maxn), rho(maxn), x(dim,maxn), vx(dim,maxn))
      allocate(itype_d(maxn), ind_d(maxn), p_d(maxn), rho_d(maxn), x_d(dim,maxn), vx_d(dim,maxn))
      allocate (pairs(maxinter), pairs_d(maxinter))

   end subroutine allocatePersistentArrays

   !==============================================================================================================================
   subroutine generate_real_part(ntotal, itype, ind, p, rho, x, vx)

      implicit none
      integer, intent(in):: ntotal
      integer, intent(out):: itype(ntotal), ind(ntotal)
      real(f), intent(out):: p(ntotal), rho(ntotal), x(dim,ntotal), vx(dim,ntotal)
      integer:: i, j, k, d, n
      real(f):: xi, yi, zi

      n = 0
      do i = 1, mp
         do j = 1, np
            do k = 1, op
               n = n + 1
               itype(n) = 1
               ind(n) = n
               p(n) = 0._f
               rho(n) = irho*(p(n)*gamma/(c**2*irho) + 1)**(1._f/gamma)
               x(1,n) = (i - 0.5_f)*dxo
               x(2,n) = (j - 0.5_f)*dxo
               x(3,n) = (k - 0.5_f)*dxo
               vx(:,n) = 0._f
            end do
         end do
      end do

   end subroutine generate_real_part

   !==============================================================================================================================
   subroutine generate_virt_part(ntotal, nvirt, itype, ind, p, rho, x, vx)

      implicit none
      integer, intent(in):: ntotal, nvirt
      integer, intent(out):: itype(ntotal+nvirt), ind(ntotal+nvirt)
      real(f), intent(out):: p(ntotal+nvirt), rho(ntotal+nvirt), x(dim,ntotal+nvirt), vx(dim,ntotal+nvirt)
      integer:: i, j, k, d, n

      n = ntotal

      do i = 1 - nlayer, pp + nlayer
         do j = 1 - nlayer, qp + nlayer
            do k = 1 - nlayer, rp + nlayer
               if (.not.(i>=1 .and. i<=pp .and. j>=1 .and. j<=qp .and. k>=1 .and. k<=rp)) then
                  n = n + 1
                  if (k < 1) then
                     itype(n) = -1
                  else if (k > rp) then
                     itype(n) = -2
                  else if (i < 1) then
                     itype(n) = -3
                  else if (i>pp) then
                     itype(n) = -4
                  else if (j < 1) then
                     itype(n) = -5
                  else if (j > qp) then
                     itype(n) = -6
                  end if
                  ind(n) = n
                  p(n) = 0._f
                  rho(n) = irho
                  x(1,n) = vxmin + (i - 0.5_f)*dxo
                  x(2,n) = vymin + (j - 0.5_f)*dxo
                  x(3,n) = vzmin + (k - 0.5_f)*dxo
                  vx(:,n) = 0._f
               end if
            end do
         end do
      end do

   end subroutine generate_virt_part

   !===============================================================================================================================
   attributes(global) subroutine vmat_update(maxinter_perp, nt, nv, ng, nij, pij, pts, vw)

      implicit none
      integer, intent(in):: maxinter_perp, nt, nv, ng, nij(nt + nv + ng)
      type(interactions), intent(in):: pij(maxinter_perp, nt + nv + ng)
      real(f), intent(inout):: vw(nv)
      type(particles), intent(inout):: pts(nt + nv + ng)
      integer:: i, j, k, d
      real(f):: tmp, tmp2

      i = blockDim%x*(blockIdx%x - 1) + threadIdx%x

      if (i <= nt + nv + ng) then
         do k = 1, nij(i)
            j = pij(k, i)%j
            if (pts(i)%itype < 0 .and. pts(j)%itype > 0) then
               tmp = mass*pij(k, i)%w/pts(j)%rho
               tmp2 = atomicadd(vw(pts(i)%indloc - nt), tmp)
               tmp2 = atomicadd(pts(i)%rho, mass*pij(k, i)%w)
               select case (pts(i)%itype)
               case (-1) ! top-bottom walls
                  tmp2 = atomicadd(pts(i)%vx(1), -pts(j)%vx(1)*tmp)
                  tmp2 = atomicadd(pts(i)%vx(2), -pts(j)%vx(2)*tmp)
                  tmp2 = atomicadd(pts(i)%vx(3), -pts(j)%vx(3)*tmp)
               case (-2) ! north-south walls
                  tmp2 = atomicadd(pts(i)%vx(1), pts(j)%vx(1)*tmp)
                  tmp2 = atomicadd(pts(i)%vx(2), -pts(j)%vx(2)*tmp)
                  tmp2 = atomicadd(pts(i)%vx(3), pts(j)%vx(3)*tmp)
               case (-3) ! east-west walls
                  tmp2 = atomicadd(pts(i)%vx(1), -pts(j)%vx(1)*tmp)
                  tmp2 = atomicadd(pts(i)%vx(2), pts(j)%vx(2)*tmp)
                  tmp2 = atomicadd(pts(i)%vx(3), pts(j)%vx(3)*tmp)
               end select
            else if (pts(j)%itype < 0 .and. pts(i)%itype > 0) then
               tmp = mass*pij(k, i)%w/pts(i)%rho
               tmp2 = atomicadd(vw(pts(j)%indloc - nt), tmp)
               tmp2 = atomicadd(pts(j)%rho, mass*pij(k, i)%w)
               select case (pts(j)%itype)
               case (-1) ! top-bottom walls
                  tmp2 = atomicadd(pts(j)%vx(1), -pts(i)%vx(1)*tmp)
                  tmp2 = atomicadd(pts(j)%vx(2), -pts(i)%vx(2)*tmp)
                  tmp2 = atomicadd(pts(j)%vx(3), -pts(i)%vx(3)*tmp)
               case (-2) ! north-south walls
                  tmp2 = atomicadd(pts(j)%vx(1), pts(i)%vx(1)*tmp)
                  tmp2 = atomicadd(pts(j)%vx(2), -pts(i)%vx(2)*tmp)
                  tmp2 = atomicadd(pts(j)%vx(3), pts(i)%vx(3)*tmp)
               case (-3) ! east-west walls
                  tmp2 = atomicadd(pts(j)%vx(1), -pts(i)%vx(1)*tmp)
                  tmp2 = atomicadd(pts(j)%vx(2), pts(i)%vx(2)*tmp)
                  tmp2 = atomicadd(pts(j)%vx(3), pts(i)%vx(3)*tmp)
               end select
            end if
         end do
      end if

   end subroutine vmat_update

end module input_m
