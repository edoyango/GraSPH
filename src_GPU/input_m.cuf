module input_m

   use datatypes, only: particles, interactions
   use param, only: dim, f, dxo, mp, np, op, pp, qp, rp, nlayer, irho, g, gamma, c, hsml, mass

   private
   real(f), parameter, public:: vxmin = 0._f, vymin = 0._f, vzmin = 0._f, &
                                vxmax = vxmin + pp*dxo, vymax = vymin + qp*dxo, vzmax = vzmin + rp*dxo
   real(f), parameter, public:: rxmin = 0._f, rymin = 0._f, rzmin = 0._f, &
                                rxmax = rxmin + mp*dxo, rymax = rymin + np*dxo, rzmax = rzmin + op*dxo

   public:: return_ntotal, return_nvirt, allocatePersistentArrays, generate_real_part, generate_virt_part, &
            generate_ghost_part, update_ghost_part

contains

   !==============================================================================================================================
   pure function return_ntotal() result(ntotal)

      implicit none
      integer:: ntotal

      ntotal = mp*np*op

   end function return_ntotal

   !==============================================================================================================================
   pure function return_nvirt() result(nvirt)

      implicit none
      integer:: nvirt, i, j, k
      
      nvirt = 0
      do i = 1 - nlayer, pp + nlayer
         do j = 1 - nlayer, qp + nlayer
            do k = 1 - nlayer, rp + nlayer
               if (.not.(i>=1 .and. i<=pp .and. j>=1 .and. j<=qp .and. k>=1 .and. k<=rp)) then
                  nvirt = nvirt + 1
               end if
            end do
         end do
      end do

   end function return_nvirt

   !==============================================================================================================================
   subroutine allocatePersistentArrays(ntotal, nvirt, maxn, maxinter_perp, parts, parts_d, pairs, pairs_d, niac, niac_d)

      implicit none
      integer, intent(in):: ntotal, nvirt, maxinter_perp
      integer, intent(out):: maxn
      integer, allocatable, intent(inout):: niac(:)
      integer, allocatable, intent(inout), device:: niac_d(:)
      type(particles), allocatable, intent(inout):: parts(:)
      type(particles), allocatable, intent(inout), device:: parts_d(:)
      type(interactions), allocatable, intent(inout):: pairs(:, :)
      type(interactions), allocatable, intent(inout), device:: pairs_d(:, :)

      maxn = ntotal + nvirt!+int(0.2*ntotal)

      allocate (parts(maxn), parts_d(maxn))
      allocate (pairs(maxinter_perp, maxn), pairs_d(maxinter_perp, maxn))
      allocate (niac(maxn), niac_d(maxn))

   end subroutine allocatePersistentArrays

   !==============================================================================================================================
   subroutine generate_real_part(ntotal, parts)

      implicit none
      integer, intent(in):: ntotal
      type(particles), intent(out):: parts(:)
      integer:: i, j, k, d, n
      real(f):: xi, yi, zi

      n = 0
      do i = 1, mp
         do j = 1, np
            do k = 1, op
               n = n + 1
               parts(n)%indloc = n
               parts(n)%indglob = n
               parts(n)%x(1) = (i - 0.5_f)*dxo
               parts(n)%x(2) = (j - 0.5_f)*dxo
               parts(n)%x(3) = (k - 0.5_f)*dxo
               parts(n)%vx(:) = 0._f
               parts(n)%itype = 1
               parts(n)%p = 0._f!(zl-parts(n)%x(3))*g*irho
               parts(n)%rho = irho*(parts(n)%p*gamma/(c**2*irho) + 1)**(1._f/gamma)

            end do
         end do
      end do

   end subroutine generate_real_part

   !==============================================================================================================================
   subroutine generate_virt_part(ntotal, nvirt, parts)

      implicit none
      integer, intent(in):: ntotal, nvirt
      type(particles), intent(inout):: parts(:)
      integer:: i, j, k, d, n

      n = ntotal

      do i = 1 - nlayer, pp + nlayer
         do j = 1 - nlayer, qp + nlayer
            do k = 1 - nlayer, rp + nlayer
               if (.not.(i>=1 .and. i<=pp .and. j>=1 .and. j<=qp .and. k>=1 .and. k<=rp)) then
                  n = n + 1
                  parts(n)%indloc = n
                  parts(n)%indglob = n
                  parts(n)%x(1) = vxmin + (i - 0.5_f)*dxo
                  parts(n)%x(2) = vymin + (j - 0.5_f)*dxo
                  parts(n)%x(3) = vzmin + (k - 0.5_f)*dxo
                  parts(n)%vx(:) = 0._f
                  parts(n)%rho = irho
                  parts(n)%p = 0._f
                  if (k < 1) then
                     parts(n)%itype = -1
                  else if (k > rp) then
                     parts(n)%itype = -2
                  else if (i < 1) then
                     parts(n)%itype = -3
                  else if (i>pp) then
                     parts(n)%itype = -4
                  else if (j < 1) then
                     parts(n)%itype = -5
                  else if (j > qp) then
                     parts(n)%itype = -6
                  end if
               end if
            end do
         end do
      end do

   end subroutine generate_virt_part

   !===============================================================================================================================
   attributes(global) subroutine vmat_update(maxinter_perp, nt, nv, ng, nij, pij, pts, vw)

      implicit none
      integer, intent(in):: maxinter_perp, nt, nv, ng, nij(nt + nv + ng)
      type(interactions), intent(in):: pij(maxinter_perp, nt + nv + ng)
      real(f), intent(inout):: vw(nv)
      type(particles), intent(inout):: pts(nt + nv + ng)
      integer:: i, j, k, d
      real(f):: tmp, tmp2

      i = blockDim%x*(blockIdx%x - 1) + threadIdx%x

      if (i <= nt + nv + ng) then
         do k = 1, nij(i)
            j = pij(k, i)%j
            if (pts(i)%itype < 0 .and. pts(j)%itype > 0) then
               tmp = mass*pij(k, i)%w/pts(j)%rho
               tmp2 = atomicadd(vw(pts(i)%indloc - nt), tmp)
               tmp2 = atomicadd(pts(i)%rho, mass*pij(k, i)%w)
               select case (pts(i)%itype)
               case (-1) ! top-bottom walls
                  tmp2 = atomicadd(pts(i)%vx(1), -pts(j)%vx(1)*tmp)
                  tmp2 = atomicadd(pts(i)%vx(2), -pts(j)%vx(2)*tmp)
                  tmp2 = atomicadd(pts(i)%vx(3), -pts(j)%vx(3)*tmp)
               case (-2) ! north-south walls
                  tmp2 = atomicadd(pts(i)%vx(1), pts(j)%vx(1)*tmp)
                  tmp2 = atomicadd(pts(i)%vx(2), -pts(j)%vx(2)*tmp)
                  tmp2 = atomicadd(pts(i)%vx(3), pts(j)%vx(3)*tmp)
               case (-3) ! east-west walls
                  tmp2 = atomicadd(pts(i)%vx(1), -pts(j)%vx(1)*tmp)
                  tmp2 = atomicadd(pts(i)%vx(2), pts(j)%vx(2)*tmp)
                  tmp2 = atomicadd(pts(i)%vx(3), pts(j)%vx(3)*tmp)
               end select
            else if (pts(j)%itype < 0 .and. pts(i)%itype > 0) then
               tmp = mass*pij(k, i)%w/pts(i)%rho
               tmp2 = atomicadd(vw(pts(j)%indloc - nt), tmp)
               tmp2 = atomicadd(pts(j)%rho, mass*pij(k, i)%w)
               select case (pts(j)%itype)
               case (-1) ! top-bottom walls
                  tmp2 = atomicadd(pts(j)%vx(1), -pts(i)%vx(1)*tmp)
                  tmp2 = atomicadd(pts(j)%vx(2), -pts(i)%vx(2)*tmp)
                  tmp2 = atomicadd(pts(j)%vx(3), -pts(i)%vx(3)*tmp)
               case (-2) ! north-south walls
                  tmp2 = atomicadd(pts(j)%vx(1), pts(i)%vx(1)*tmp)
                  tmp2 = atomicadd(pts(j)%vx(2), -pts(i)%vx(2)*tmp)
                  tmp2 = atomicadd(pts(j)%vx(3), pts(i)%vx(3)*tmp)
               case (-3) ! east-west walls
                  tmp2 = atomicadd(pts(j)%vx(1), -pts(i)%vx(1)*tmp)
                  tmp2 = atomicadd(pts(j)%vx(2), pts(i)%vx(2)*tmp)
                  tmp2 = atomicadd(pts(j)%vx(3), pts(i)%vx(3)*tmp)
               end select
            end if
         end do
      end if

   end subroutine vmat_update

end module input_m
