module single_step_m

   use datatypes, only: interactions, particles
   use param, only: dim, f, g, mass

   public:: single_step_kernel
   private:: art_visc, ext_force, int_force, con_density

contains

   !==============================================================================================================================
   attributes(global) pure subroutine single_step_kernel(ki, maxinter_perp, np, nij, pij, itype, ind, p, rho, x, vx, dvxdti, drhodti)

      implicit none
      integer, intent(in), value:: ki, maxinter_perp, np
      integer, intent(in):: nij(np), itype(np), ind(np)
      real, intent(in):: p(np), rho(np), x(dim,np),vx(dim,np)
      type(interactions), intent(in):: pij(maxinter_perp, np)
      real(f), intent(inout):: dvxdti(dim, np), drhodti(np)
      integer:: i, j, k, d, itype_i, itype_j, ind_i, ind_j
      real(f):: a_coeff, tmp, vcc, p_i, p_j, rho_i, rho_j, x_i(dim), x_j(dim), vx_i(dim), vx_j(dim)

      ! Obtaining thread global index (used to assign particle index)
      i = blockDim%x*(blockIdx%x - 1) + threadIdx%x

      ! Beginning loop over
      if (i <= nt + nv) then
         
         itype_i = itype(i)
         ind_i = ind(i)
         p_i = p(i)
         rho_i = rho(i)
         x_i = x(:,i)
         vx_i = vx(:,i)

         do k = 1, nij(i)

            j = pij(k, i)%j
            
            itype_j = itype(j)
            ind_j = ind(j)
            p_j = p(j)
            rho_j = rho(j)
            x_j = x(:,j)
            vx_j = vx(:,j)

            ! Mirroring real particle onto virtual particle (if needed)
            if (itype_i > 0 .and. itype_j < 0) then
               call virt_mirror(itype_i, p_i, rho_i, x_i, vx_i, itype_j, p_j, rho_j, x_j, vx_j)
            elseif (itype_i < 0 .and. itype_j > 0) then
               call virt_mirror(itype_j, p_j, rho_j, x_j, vx_j, itype_i, p_i, rho_i, x_i, vx_i)
            end if

            !Density approximation or change rate
            call con_density(ki, nt, nv, ind_i, ind_j, vx_i, vx_j, pij(k, i)%dwdx, drhodti(i), drhodti(j))
            
            ! calculating coefficients for pressure force and artificial viscosity
            a_coeff = int_force_coeff(ki, ind_i, ind_j, p_i, p_j, rho_i, rho_j) + art_visc_coeff(ki, ind_i, ind_j, rho_i, rho_j, x_i, x_j, vx_i, vx_j)
            do d = 1, dim
               tmp = atomicadd(dvxdti(d, i), pij(k, i)%dwdx(d)*a_coeff)
               tmp = atomicadd(dvxdti(d, j), -pij(k, i)%dwdx(d)*a_coeff)
            end do

         end do
      end if

   end subroutine single_step_kernel

   !==============================================================================================================================
   attributes(device) pure subroutine virt_mirror(itype_r, p_r, rho_r, x_r, vx_r, itype_v, p_v, rho_v, x_v, vx_v)

      use input_m, only: vzmin, vzmax, vxmin, vxmax, vymin, vymax

      implicit none
      integer, intent(in):: itype_r, itype_v
      real(f), intent(in):: p_r, rho_r, x_r(dim), vx_r(dim), x_v(dim)
      real(f), intent(out):: p_v, rho_v, vx_v(dim)
      real(f):: da, db, beta
      real(f), parameter:: beta_max = 5._f

      select case (itype_v)
        case default
          da = ABS(x_r(3) - vzmin)
          db = ABS(x_v(3) - vzmin)
        case (-2)
          da = ABS(x_r(3) - vzmax)
          db = ABS(x_v(3) - vzmax)
        case (-3)
          da = ABS(x_r(1) - vxmin)
          db = ABS(x_v(1) - vxmin)
        case (-4)
          da = ABS(x_r(1) - vxmax)
          db = ABS(x_v(1) - vxmax)
        case (-5)
          da = ABS(x_r(2) - vymin)
          db = ABS(x_v(2) - vymin)
        case (-6)
          da = ABS(x_r(2) - vymax)
          db = ABS(x_v(2) - vymax)
      end select
      
         beta = MIN(db/da, beta_max)
         if (da == 0._f) beta = beta_max
          
      select case (itype_v)
        case default
          vx_v(1) = -beta*vx_r(1)
          vx_v(2) = -beta*vx_r(2)
          vx_v(3) = -beta*vx_r(3)
        case (-2)            
          vx_V(1) =  beta*vx_r(1)
          vx_V(2) =  beta*vx_r(2)
          vx_V(3) = -beta*vx_r(3)
        case (-3, -4)        
          vx_v(1) = -beta*vx_r(1)
          vx_v(2) =  beta*vx_r(2)
          vx_v(3) =  beta*vx_r(3)
        case (-5, -6)        
          vx_v(1) =  beta*vx_r(1)
          vx_v(2) = -beta*vx_r(2)
          vx_v(3) =  beta*vx_r(3)
      end select
         
      
!~       beta = MIN(db/da, beta_max)
!~       if (da == 0._f) beta = beta_max

      rho_v = rho_r
      p_v = p_r
!~       pv%vx(:) = -beta*pr%vx(:)

   end subroutine virt_mirror

   !=================================================================================
   attributes(device) pure subroutine ext_force(ki, nt, nv, ng, p_i, p_j, dwdx, exdvxdti, exdvxdtj)

      use param, only: p1, p2, rr0, dd

      implicit none
      integer, intent(in):: ki, nt, nv, ng
      type(particles), intent(in):: p_i, p_j
      real(f), intent(in):: dwdx(dim)
      real(f), intent(inout):: exdvxdti(dim), exdvxdtj(dim)
      real(f):: dx(dim), rr, fo, tmp
      integer:: d

      dx(:) = p_i%x(:) - p_j%x(:)
      rr = SQRT(SUM(dx(:)*dx(:)))

      if (rr .lt. rr0) then
         fo = ((rr0/rr)**p1 - (rr0/rr)**p2)/rr**2
         do d = 1, dim
            tmp = atomicAdd(exdvxdti(d), dd*dx(d)*fo)
            tmp = atomicAdd(exdvxdtj(d), -dd*dx(d)*fo)
         end do
      end if

   end subroutine ext_force

   !=================================================================================
   attributes(device) pure subroutine con_density(ki, nt, nv, ind_i, ind_j, vx_i, vx_j, dwdx, codrhodti, codrhodtj)

      implicit none
      integer, intent(in):: ki, nt, nv, ind_i, ind_j
      real(f), intent(in):: dwdx(dim), vx_i(dim), vx_j(dim)
      real(f), intent(inout):: codrhodti, codrhodtj
      real(f):: dvx(dim), vcc, tmp

      dvx(:) = vx_i(dim) - vx_j(dim)

      vcc = DOT_PRODUCT(dvx(:), dwdx(:))

      tmp = atomicAdd(codrhodti, mass*vcc)
      tmp = atomicAdd(codrhodtj, mass*vcc)

   end subroutine con_density

   !=================================================================================
   attributes(device) pure function art_visc_coeff(ki, ind_i, ind_j, rho_i, rho_j, x_i, x_j, vx_i, vx_j) result(coeff)

      use param, only: alpha, beta, etq, hsml, c

      implicit none
      integer, intent(in):: ki, ind_i, ind_j
      real(f), intent(in):: rho_i, rho_j, x_i(dim), x_j(dim), vx_i(dim), vx_j(dim)
      real(f):: dx(dim), piv(dim), muv, vr, rr, mrho, coeff

      dx(:) = x_i(:) - x_j(:)
      vr = DOT_PRODUCT(vx_i(:) - vx_j(:), dx(:))
      if (vr > 0._f) vr = 0._f !Artificial viscous force only if v_ij * r_ij < 0

      rr = DOT_PRODUCT(dx(:), dx(:))
      muv = hsml*vr/(rr + hsml*hsml*etq*etq)
      mrho = 0.5_f*(rho_i + rho_j)
      coeff = -mass*(beta*muv - alpha*c)*muv/mrho

   end function art_visc_coeff

   !=================================================================================
   attributes(device) pure function int_force_coeff(ki, ind_i, ind_j, p_i, p_j, rho_i, rho_j) result(coeff)

      implicit none
      integer, intent(in):: ki, ind_i, ind_j
      real(f), intent(in):: p_i, p_j, rho_i, rho_j
      real(f):: coeff

      coeff = -mass*(p_i/rho_i**2 + p_j/rho_j**2)

   end function int_force_coeff

end module single_step_m
