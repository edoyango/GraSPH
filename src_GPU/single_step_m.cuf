module single_step_m

   use datatypes, only: interactions, particles
   use param, only: dim, f, g, mass

   public:: single_step_kernel
   private:: art_visc, ext_force, int_force, con_density

contains

   !==============================================================================================================================
   attributes(global) pure subroutine single_step_kernel(ki, maxinter_perp, nt, nv, nij, pij, pts, dvxdti, drhodti)

      implicit none
      integer, intent(in), value:: ki, maxinter_perp
      integer, intent(in):: nt, nv, nij(nt + nv)
      type(interactions), intent(in):: pij(maxinter_perp, nt+nv)
      type(particles), intent(in):: pts(nt + nv)
      real(f), intent(inout):: dvxdti(dim, nt+nv), drhodti(nt+nv)
      integer:: i, j, k, d
      real(f):: a_coeff, tmp, vcc
      type(particles):: p_i, p_j

      ! Obtaining thread global index (used to assign particle index)
      i = blockDim%x*(blockIdx%x - 1) + threadIdx%x

      ! Beginning loop over
      if (i <= nt + nv) then

         p_i = pts(i)

         do k = 1, nij(i)

            j = pij(k, i)%j
            p_j = pts(j)

            ! Mirroring real particle onto virtual particle (if needed)
            if (p_i%itype > 0 .and. p_j%itype < 0) then
               call virt_mirror(p_i, p_j)
            elseif (p_i%itype < 0 .and. p_j%itype > 0) then
               call virt_mirror(p_j, p_i)
            end if

            !Density approximation or change rate
            call con_density(ki, nt, nv, p_i, p_j, pij(k, i)%dwdx, drhodti(i), drhodti(j))
            
            ! calculating coefficients for pressure force and artificial viscosity
            a_coeff = int_force_coeff(ki, p_i, p_j) + art_visc_coeff(ki, p_i, p_j)
            do d = 1, dim
               tmp = atomicadd(dvxdti(d, i), pij(k, i)%dwdx(d)*a_coeff)
               tmp = atomicadd(dvxdti(d, j), -pij(k, i)%dwdx(d)*a_coeff)
            end do

         end do
      end if

   end subroutine single_step_kernel

   !==============================================================================================================================
   attributes(device) pure subroutine virt_mirror(pr, pv)

      use input_m, only: vzmin, vzmax, vxmin, vxmax, vymin, vymax

      implicit none
      type(particles), intent(in):: pr
      type(particles), intent(inout):: pv
      real(f):: da, db, beta
      real(f), parameter:: beta_max = 5._f

      select case (pv%itype)
        case default
          da = ABS(pr%x(3) - vzmin)
          db = ABS(pv%x(3) - vzmin)
        case (-2)
          da = ABS(pr%x(3) - vzmax)
          db = ABS(pv%x(3) - vzmax)
        case (-3)
          da = ABS(pr%x(1) - vxmin)
          db = ABS(pv%x(1) - vxmin)
        case (-4)
          da = ABS(pr%x(1) - vxmax)
          db = ABS(pv%x(1) - vxmax)
        case (-5)
          da = ABS(pr%x(2) - vymin)
          db = ABS(pv%x(2) - vymin)
        case (-6)
          da = ABS(pr%x(2) - vymax)
          db = ABS(pv%x(2) - vymax)
      end select
      
         beta = MIN(db/da, beta_max)
         if (da == 0._f) beta = beta_max
          
      select case (pv%itype)
        case default
          pv%vx(1) = -beta*pr%vx(1)
          pv%vx(2) = -beta*pr%vx(2)
          pv%vx(3) = -beta*pr%vx(3)
        case (-2)
          pv%vx(1) =  beta*pr%vx(1)
          pv%vx(2) =  beta*pr%vx(2)
          pv%vx(3) = -beta*pr%vx(3)
        case (-3, -4)
          pv%vx(1) = -beta*pr%vx(1)
          pv%vx(2) =  beta*pr%vx(2)
          pv%vx(3) =  beta*pr%vx(3)
        case (-5, -6)
          pv%vx(1) =  beta*pr%vx(1)
          pv%vx(2) = -beta*pr%vx(2)
          pv%vx(3) =  beta*pr%vx(3)
      end select
         
      
!~       beta = MIN(db/da, beta_max)
!~       if (da == 0._f) beta = beta_max

      pv%rho = pr%rho
      pv%p = pr%p
!~       pv%vx(:) = -beta*pr%vx(:)

   end subroutine virt_mirror

   !=================================================================================
   attributes(device) pure subroutine ext_force(ki, nt, nv, ng, p_i, p_j, dwdx, exdvxdti, exdvxdtj)

      use param, only: p1, p2, rr0, dd

      implicit none
      integer, intent(in):: ki, nt, nv, ng
      type(particles), intent(in):: p_i, p_j
      real(f), intent(in):: dwdx(dim)
      real(f), intent(inout):: exdvxdti(dim), exdvxdtj(dim)
      real(f):: dx(dim), rr, fo, tmp
      integer:: d

      dx(:) = p_i%x(:) - p_j%x(:)
      rr = SQRT(SUM(dx(:)*dx(:)))

      if (rr .lt. rr0) then
         fo = ((rr0/rr)**p1 - (rr0/rr)**p2)/rr**2
         do d = 1, dim
            tmp = atomicAdd(exdvxdti(d), dd*dx(d)*fo)
            tmp = atomicAdd(exdvxdtj(d), -dd*dx(d)*fo)
         end do
      end if

   end subroutine ext_force

   !=================================================================================
   attributes(device) pure subroutine con_density(ki, nt, nv, p_i, p_j, dwdx, codrhodti, codrhodtj)

      implicit none
      integer, intent(in):: ki, nt, nv
      type(particles), intent(in):: p_i, p_j
      real(f), intent(in):: dwdx(dim)
      real(f), intent(inout):: codrhodti, codrhodtj
      real(f):: dvx(dim), vcc, tmp

      dvx(:) = p_i%vx(:) - p_j%vx(:)

      vcc = DOT_PRODUCT(dvx(:), dwdx(:))

      tmp = atomicAdd(codrhodti, mass*vcc)
      tmp = atomicAdd(codrhodtj, mass*vcc)

   end subroutine con_density

   !=================================================================================
   attributes(device) pure function art_visc_coeff(ki, p_i, p_j) result(coeff)

      use param, only: alpha, beta, etq, hsml, c

      implicit none
      integer, intent(in):: ki
      type(particles), intent(in):: p_i, p_j
      real(f):: dx(dim), piv(dim), muv, vr, rr, mrho, coeff

      dx(:) = p_i%x(:) - p_j%x(:)
      vr = DOT_PRODUCT(p_i%vx(:) - p_j%vx(:), dx(:))
      if (vr > 0._f) vr = 0._f !Artificial viscous force only if v_ij * r_ij < 0

      rr = DOT_PRODUCT(dx(:), dx(:))
      muv = hsml*vr/(rr + hsml*hsml*etq*etq)
      mrho = 0.5_f*(p_i%rho + p_j%rho)
      coeff = -mass*(beta*muv - alpha*c)*muv/mrho

   end function art_visc_coeff

   !=================================================================================
   attributes(device) pure function int_force_coeff(ki, p_i, p_j) result(coeff)

      implicit none
      integer, intent(in):: ki
      type(particles), intent(in):: p_i, p_j
      real(f):: coeff

      coeff = -mass*(p_i%p/p_i%rho**2 + p_j%p/p_j%rho**2)

   end function int_force_coeff

end module single_step_m
