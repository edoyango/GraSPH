module single_step_m

   use datatypes, only: interactions, particles
   use param, only: dim, f, g, mass
   
   private
   integer, pointer, texture:: itype_ss_Tex(:), ind_ss_Tex(:)
   real(f), pointer, texture:: p_ss_Tex(:), rho_ss_Tex(:), x_ss_Tex(:,:), vx_ss_Tex(:,:)

   public:: single_step_kernel, itype_ss_Tex, ind_ss_Tex, p_ss_Tex, rho_ss_Tex, x_ss_Tex, vx_ss_Tex

contains

   !==============================================================================================================================
   attributes(global) pure subroutine single_step_kernel(ki, maxinter, np, nij, pij, dvxdti, drhodti)

      implicit none
      integer, intent(in), value:: ki, maxinter, np
      integer, intent(in):: nij
      type(interactions), intent(in):: pij(maxinter)
      real(f), intent(inout):: dvxdti(dim, np), drhodti(np)
      integer:: i, j, k, d, itype_i, itype_j, ind_i, ind_j
      real(f):: a_coeff, tmp, vcc, p_i, p_j, rho_i, rho_j, x_i(dim), x_j(dim), vx_i(dim), vx_j(dim)

      ! Obtaining thread global index (used to assign particle index)
      k = blockDim%x*(blockIdx%x - 1) + threadIdx%x

      ! Beginning loop over
      if (k <= nij) then
         
         i = pij(k)%i
         j = pij(k)%j
         itype_i = itype_ss_Tex(i)
         itype_j = itype_ss_Tex(j)
         ind_i = ind_ss_Tex(i)
         rho_i = rho_ss_Tex(i)
         p_i = p_ss_Tex(i)
         x_i = x_ss_Tex(:,i)
         vx_i = vx_ss_Tex(:,i)
         ind_j = ind_ss_Tex(j)
         rho_j = rho_ss_Tex(j)
         p_j = p_ss_Tex(j)
         x_j = x_ss_Tex(:,j)
         vx_j = vx_ss_Tex(:,j)

            ! Mirroring real particle onto virtual particle (if needed)
         if (itype_i > 0 .and. itype_j < 0) then
            call virt_mirror(ind_i, ind_j, p_i, p_j, rho_i, rho_j, x_i, x_j, vx_i, vx_j , itype_j)
         elseif (itype_i < 0 .and. itype_j > 0) then
            call virt_mirror(ind_j, ind_i, p_j, p_i, rho_j, rho_i, x_j, x_i, vx_j, vx_i , itype_i)
         end if

         !Density approximation or change rate
         call con_density(ki, ind_i, ind_j, vx_i, vx_j,pij(k)%dwdx, drhodti(i), drhodti(j))
            
         ! calculating coefficients for pressure force and artificial viscosity
         a_coeff = int_force_coeff(ki, ind_i, ind_j, p_i, p_j, rho_i, rho_j) + &
                   art_visc_coeff(ki, ind_i, ind_j, rho_i, rho_j, x_i, x_j, vx_i, vx_j)
                      
         do d = 1, dim
            tmp = atomicadd(dvxdti(d, i), pij(k)%dwdx(d)*a_coeff)
            tmp = atomicadd(dvxdti(d, j), -pij(k)%dwdx(d)*a_coeff)
         end do

      end if

   end subroutine single_step_kernel

   !==============================================================================================================================
   attributes(device) pure subroutine virt_mirror(indr,indv,pr,pv,rhor,rhov,xr,xv,vxr,vxv,itypev)

      use input_m, only: vzmin, vzmax, vxmin, vxmax, vymin, vymax

      implicit none
      integer, intent(in):: indr, indv, itypev
      real(f), intent(in):: xr(dim), xv(dim), pr, rhor, vxr(dim)
      real(f), intent(out):: pv, rhov, vxv(dim)
      real(f):: da, db, beta
      real(f), parameter:: beta_max = 5._f

      select case (itypev)
        case default
          da = ABS(xr(3) - vzmin)
          db = ABS(xv(3) - vzmin)
        case (-2)
          da = ABS(xr(3) - vzmax)
          db = ABS(xv(3) - vzmax)
        case (-3)
          da = ABS(xr(1) - vxmin)
          db = ABS(xv(1) - vxmin)
        case (-4)
          da = ABS(xr(1) - vxmax)
          db = ABS(xv(1) - vxmax)
        case (-5)
          da = ABS(xr(2) - vymin)
          db = ABS(xv(2) - vymin)
        case (-6)
          da = ABS(xr(2) - vymax)
          db = ABS(xv(2) - vymax)
      end select
      
         beta = MIN(db/da, beta_max)
         if (da == 0._f) beta = beta_max
          
      select case (itypev)
        case default
          vxv(1) = -beta*vxr(1)
          vxv(2) = -beta*vxr(2)
          vxv(3) = -beta*vxr(3)
        case (-2)
          vxv(1) =  beta*vxr(1)
          vxv(2) =  beta*vxr(2)
          vxv(3) = -beta*vxr(3)
        case (-3, -4)
          vxv(1) = -beta*vxr(1)
          vxv(2) =  beta*vxr(2)
          vxv(3) =  beta*vxr(3)
        case (-5, -6)
          vxv(1) =  beta*vxr(1)
          vxv(2) = -beta*vxr(2)
          vxv(3) =  beta*vxr(3)
      end select
      
      pv = pr
      rhov = rhor

   end subroutine virt_mirror

   !=================================================================================
   attributes(device) pure subroutine ext_force(ki, nt, nv, ng, p_i, p_j, dwdx, exdvxdti, exdvxdtj)

      use param, only: p1, p2, rr0, dd

      implicit none
      integer, intent(in):: ki, nt, nv, ng
      type(particles), intent(in):: p_i, p_j
      real(f), intent(in):: dwdx(dim)
      real(f), intent(inout):: exdvxdti(dim), exdvxdtj(dim)
      real(f):: dx(dim), rr, fo, tmp
      integer:: d

      dx(:) = p_i%x(:) - p_j%x(:)
      rr = SQRT(SUM(dx(:)*dx(:)))

      if (rr .lt. rr0) then
         fo = ((rr0/rr)**p1 - (rr0/rr)**p2)/rr**2
         do d = 1, dim
            tmp = atomicAdd(exdvxdti(d), dd*dx(d)*fo)
            tmp = atomicAdd(exdvxdtj(d), -dd*dx(d)*fo)
         end do
      end if

   end subroutine ext_force

   !=================================================================================
   attributes(device) pure subroutine con_density(ki, ind_i, ind_j, vx_i, vx_j, dwdx, codrhodti, codrhodtj)

      implicit none
      integer, intent(in):: ki, ind_i, ind_j
      real(f), intent(in):: vx_i(dim), vx_j(dim), dwdx(dim)
      real(f), intent(inout):: codrhodti, codrhodtj
      real(f):: dvx(dim), vcc, tmp

      dvx(:) = vx_i(:) - vx_j(:)

      vcc = DOT_PRODUCT(dvx(:), dwdx(:))

      tmp = atomicAdd(codrhodti, mass*vcc)
      tmp = atomicAdd(codrhodtj, mass*vcc)

   end subroutine con_density

   !=================================================================================
   attributes(device) pure function art_visc_coeff(ki, ind_i, ind_j, rho_i, rho_j, x_i, x_j, vx_i, vx_j) result(coeff)

      use param, only: alpha, beta, etq, hsml, c

      implicit none
      integer, intent(in):: ki, ind_i, ind_j
      real(f), intent(in):: rho_i, rho_j, x_i(dim), x_j(dim), vx_i(dim), vx_j(dim)
      real(f):: dx(dim), piv(dim), muv, vr, rr, mrho, coeff

      dx(:) = x_i(:) - x_j(:)
      vr = DOT_PRODUCT(vx_i(:) - vx_j(:), dx(:))
      if (vr > 0._f) vr = 0._f !Artificial viscous force only if v_ij * r_ij < 0

      rr = DOT_PRODUCT(dx(:), dx(:))
      muv = hsml*vr/(rr + hsml*hsml*etq*etq)
      mrho = 0.5_f*(rho_i + rho_j)
      coeff = -mass*(beta*muv - alpha*c)*muv/mrho

   end function art_visc_coeff

   !=================================================================================
   attributes(device) pure function int_force_coeff(ki, ind_i, ind_j, p_i, p_j, rho_i, rho_j) result(coeff)

      implicit none
      integer, intent(in):: ki, ind_i, ind_j
      real(f), intent(in):: p_i, p_j, rho_i, rho_j
      real(f):: coeff

      coeff = -mass*(p_i/rho_i**2 + p_j/rho_j**2)

   end function int_force_coeff

end module single_step_m
