module single_step_m

   use datatypes, only: interactions, particles
   use param, only: dim, f, g, mass
   
   private

   public:: single_step_kernel

contains

   !==============================================================================================================================
   attributes(global) pure subroutine single_step_kernel(ki, ind, itype, x, vx, rho, p, maxinter, np, nij, pij, dwdx, dvxdti, drhodti)

      implicit none
      integer, intent(in), value:: ki, maxinter, np
      integer, intent(in):: nij, ind(np), itype(np), pij(2, maxinter)
      real(f), intent(in):: x(dim, np), vx(dim, np), rho(np), p(np), dwdx(dim, maxinter)
      ! type(interactions), intent(in):: pij(maxinter)
      real(f), intent(inout):: dvxdti(dim, np), drhodti(np)
      integer:: i, j, k, d, itype_i, itype_j, ind_i, ind_j
      real(f):: a_coeff, tmp, vcc, p_i, p_j, rho_i, rho_j, x_i(dim), x_j(dim), vx_i(dim), vx_j(dim)

      ! Obtaining thread global index (used to assign particle index)
      k = blockDim%x*(blockIdx%x - 1) + threadIdx%x

      ! Beginning loop over
      if (k <= nij) then
         
         i = pij(1, k) !pij(k)%i
         j = pij(2, k) !pij(k)%j
         itype_i = itype(i)
         itype_j = itype(j)
         ind_i = ind(i)
         rho_i = rho(i)
         p_i = p(i)
         x_i = x(:,i)
         vx_i = vx(:,i)
         ind_j = ind(j)
         rho_j = rho(j)
         p_j = p(j)
         x_j = x(:,j)
         vx_j = vx(:,j)

         !Density approximation or change rate
         call con_density(ki, ind_i, ind_j, vx_i, vx_j, dwdx(:, k), drhodti(i), drhodti(j))
            
         ! calculating coefficients for pressure force and artificial viscosity
         a_coeff = int_force_coeff(ki, ind_i, ind_j, p_i, p_j, rho_i, rho_j) + &
                   art_visc_coeff(ki, ind_i, ind_j, rho_i, rho_j, x_i, x_j, vx_i, vx_j)
                      
         do d = 1, dim
            tmp = atomicadd(dvxdti(d, i), dwdx(d, k)*a_coeff)
            tmp = atomicadd(dvxdti(d, j), -dwdx(d, k)*a_coeff)
         end do

      end if

   end subroutine single_step_kernel

   !=================================================================================
   attributes(device) pure subroutine ext_force(ki, nt, nv, ng, p_i, p_j, dwdx, exdvxdti, exdvxdtj)

      use param, only: p1, p2, rr0, dd

      implicit none
      integer, intent(in):: ki, nt, nv, ng
      type(particles), intent(in):: p_i, p_j
      real(f), intent(in):: dwdx(dim)
      real(f), intent(inout):: exdvxdti(dim), exdvxdtj(dim)
      real(f):: dx(dim), rr, fo, tmp
      integer:: d

      dx(:) = p_i%x(:) - p_j%x(:)
      rr = SQRT(SUM(dx(:)*dx(:)))

      if (rr .lt. rr0) then
         fo = ((rr0/rr)**p1 - (rr0/rr)**p2)/rr**2
         do d = 1, dim
            tmp = atomicAdd(exdvxdti(d), dd*dx(d)*fo)
            tmp = atomicAdd(exdvxdtj(d), -dd*dx(d)*fo)
         end do
      end if

   end subroutine ext_force

   !=================================================================================
   attributes(device) pure subroutine con_density(ki, ind_i, ind_j, vx_i, vx_j, dwdx, codrhodti, codrhodtj)

      implicit none
      integer, intent(in):: ki, ind_i, ind_j
      real(f), intent(in):: vx_i(dim), vx_j(dim), dwdx(dim)
      real(f), intent(inout):: codrhodti, codrhodtj
      real(f):: dvx(dim), vcc, tmp

      dvx(:) = vx_i(:) - vx_j(:)

      vcc = DOT_PRODUCT(dvx(:), dwdx(:))

      tmp = atomicAdd(codrhodti, mass*vcc)
      tmp = atomicAdd(codrhodtj, mass*vcc)

   end subroutine con_density

   !=================================================================================
   attributes(device) pure function art_visc_coeff(ki, ind_i, ind_j, rho_i, rho_j, x_i, x_j, vx_i, vx_j) result(coeff)

      use param, only: alpha, beta, etq, hsml, c

      implicit none
      integer, intent(in):: ki, ind_i, ind_j
      real(f), intent(in):: rho_i, rho_j, x_i(dim), x_j(dim), vx_i(dim), vx_j(dim)
      real(f):: dx(dim), piv(dim), muv, vr, rr, mrho, coeff

      dx(:) = x_i(:) - x_j(:)
      vr = DOT_PRODUCT(vx_i(:) - vx_j(:), dx(:))
      if (vr > 0._f) vr = 0._f !Artificial viscous force only if v_ij * r_ij < 0

      rr = DOT_PRODUCT(dx(:), dx(:))
      muv = hsml*vr/(rr + hsml*hsml*etq*etq)
      mrho = 0.5_f*(rho_i + rho_j)
      coeff = -mass*(beta*muv - alpha*c)*muv/mrho

   end function art_visc_coeff

   !=================================================================================
   attributes(device) pure function int_force_coeff(ki, ind_i, ind_j, p_i, p_j, rho_i, rho_j) result(coeff)

      implicit none
      integer, intent(in):: ki, ind_i, ind_j
      real(f), intent(in):: p_i, p_j, rho_i, rho_j
      real(f):: coeff

      coeff = -mass*(p_i/rho_i**2 + p_j/rho_j**2)

   end function int_force_coeff

end module single_step_m
