module time_integration_m

   use datatypes, only: particles, interactions, time_tracking
   use param, only: f, dim, rh0, gamma, c, dt, mass, g, irho, hsml

   use cudafor

   use input_m, only: vmat_update, update_ghost_part, generate_ghost_part
   use flink_list_m, only: flink_list
   use output_m, only: output
   use summary_m, only: print_update
   use single_step_m, only: single_step_kernel

   private
   public:: time_integration

contains

   !==============================================================================================================================
   subroutine time_integration(scale_k, print_step, save_step, maxtimestep, timings, maxinter_perp, maxn, ntotal, nvirt, &
                               niac, niac_d, pairs, pairs_d, itype, ind, itype_d, ind_d, p, rho, x, vx, p_d, rho_d, x_d, vx_d)
      ! Subroutine responsible for the main time-integration loop

      implicit none
      real(f), intent(in):: scale_k
      integer, intent(in):: print_step, save_step, maxtimestep, maxinter_perp, maxn, ntotal, nvirt
      type(time_tracking), intent(inout):: timings
      integer, intent(inout):: itype(maxn), ind(maxn)
      integer, device, intent(out):: itype_d(maxn), ind_d(maxn)
      real(f), intent(inout):: p(maxn), rho(maxn), x(dim,maxn), vx(dim,maxn)
      real(f), device, intent(out):: p_d(maxn), rho_d(maxn), x_d(dim,maxn), vx_d(dim,maxn) 
      integer, intent(out):: niac(maxn)
      integer, device, intent(out):: niac_d(maxn)
      type(particles), allocatable:: parts(:)
      type(particles), device, allocatable:: parts_d(:)
      type(interactions), intent(out):: pairs(maxinter_perp, maxn)
      type(interactions), device, intent(out):: pairs_d(maxinter_perp, maxn)
      integer:: i, j, k, d, n, istat, ki, itimestep
      integer, device:: ntotal_d, nvirt_d
      real(f), allocatable, device:: v_min(:, :), rho_min(:), dvxdt(:, :, :), drho(:, :)
      real(f):: time
      real:: tmpTime
      type(cudaEvent):: startEvent, stopEvent, startOutputEvent, stopOutputEvent, startTestEvent, stopTestEvent
      integer, device, allocatable:: gind(:)

      ! creating cuda events and recording start event
      istat = cudaEventCreate(startEvent)
      istat = cudaEventCreate(stopEvent)
      istat = cudaEventCreate(startOutputEvent)
      istat = cudaEventCreate(stopOutputEvent)
      istat = cudaEventCreate(startTestEvent)
      istat = cudaEventCreate(stopTestEvent)
      istat = cudaEventRecord(startEvent, 0)
      allocate(parts(maxn),parts_d(maxn))
      
      ! Allocating arrays relevant to solver
      allocate (v_min(dim, maxn), rho_min(maxn), dvxdt(dim, maxn, 4), drho(maxn, 4))

      ! Transferring necessary data to GPU
!~       parts_d(:) = parts(:)
      itype_d = itype
      ind_d = ind
      itype_d = itype
      p_d = p
      rho_d = rho
      x_d = x
      vx_d = vx
      ntotal_d = ntotal
      nvirt_d = nvirt

      ! Time-integration (Leap-Frog)
      time = 0._f
      do itimestep = 1, maxtimestep
      
         !Interaction parameters, calculating neighboring particles
         call flink_list(scale_k, maxinter_perp, maxn, niac_d, pairs_d, itype_d, ind_d, p_d, rho_d, x_d, vx_d)
         
         ! Save particles' velocity, density information at start of time-step
         !$cuf kernel do <<<*,*>>>
         do i = 1, ntotal+nvirt
            rho_min(i) = rho_d(i)
            v_min(:, i) = vx_d(:,i)
!~             parts_d(i)%p = rh0*c**2*((parts_d(i)%rho/rh0)**gamma - 1._f)/gamma
         end do

         !$cuf kernel do (2) <<<(*,*),(*,*)>>>
         do ki = 1, 4
            do i = 1, ntotal+nvirt
               dvxdt(1:dim - 1, i, ki) = 0._f
               dvxdt(dim, i, ki) = -g
               drho(i, ki) = 0._f
            end do
         end do

         ! Beginning RK4 update (4 updates per timestep)
         do ki = 1, 4

            ! launching GPU kernel to calculate accelerations and density changes
            call single_step_kernel <<< maxn/32 + 1, 32 >>> (ki, maxinter_perp, maxn, niac_d, pairs_d, &
                                                             dvxdt(:, :, ki), drho(:, ki), itype_d, ind_d, p_d, rho_d, x_d, vx_d)
                                                                         
            ! launching GPU kernel to update particles' speed and density
            call RK4_update <<< maxn/1024 + 1, 1024 >>> (ki, maxn, v_min, rho_min, dvxdt, drho, itype_d, ind_d, p_d, rho_d, x_d, vx_d)
            
         end do
         
         

         ! Update time
         time = time + dt

         ! start timing of write time
         istat = cudaEventRecord(startOutputEvent, 0)

         ! write output data
         if (mod(itimestep, save_step) .eq. 0) then

            ! transfer particle data from GPU to CPU
            parts = parts_d
            do i = 1,maxn
              itype(i) = parts(i)%itype 
              ind(i) = parts(i)%indglob
              p(i) = parts(i)%p
              rho(i) = parts(i)%rho
              x(:,i) = parts(i)%x
              vx(:,i) = parts(i)%vx
              
            end do
            call output(itimestep, save_step, ntotal, nvirt, itype, ind, p, rho, x, vx)
         end if

         if (mod(itimestep, print_step) .eq. 0) then
            ! recording elapsed wall time to print to terminal
            istat = cudaEventRecord(stopEvent, 0)
            istat = cudaEventSynchronize(stopEvent)
            istat = cudaEventElapsedTime(timings%t_wall, startEvent, stopEvent)
            timings%t_wall = timings%t_wall/1000.
            istat = cudaEventRecord(startOutputEvent, 0)
            niac(:) = niac_d(:)
            call print_update(itimestep, maxtimestep, timings, time, ntotal, nvirt, niac)

         end if
         
         ! End timing of output time
         istat = cudaEventRecord(stopOutputEvent, 0)
         istat = cudaEventSynchronize(stopOutputEvent)
         istat = cudaEventElapsedTime(tmpTime, startOutputEvent, stopOutputEvent)
         timings%t_output = timings%t_output + tmpTime/1000.

      end do

      ! Ending timing of compute
      istat = cudaEventRecord(stopEvent, 0)
      istat = cudaEventSynchronize(stopEvent)
      istat = cudaEventElapsedTime(timings%t_wall, startEvent, stopEvent)
      timings%t_wall = timings%t_wall/1000.

   end subroutine time_integration

   !===============================================================================================================================
   attributes(global) pure subroutine RK4_update(ki, np, v_min, rho_min, dvxdt, drhodt, itype, ind, p, rho, x, vx)

      implicit none
      integer, intent(in), value:: ki, np
      integer, intent(in):: itype(np), ind(np)
      real(f), intent(in):: v_min(dim, np), rho_min(np), dvxdt(dim, np, 4), drhodt(np, 4)
      real(f), intent(inout):: p(np), rho(np), x(dim,np), vx(dim,np)
      integer:: i

      i = blockDim%x*(blockIdx%x - 1) + threadIdx%x

      if (i <= np .and. itype(i)==1) then
         select case (ki)
         case default
            vx(:,i) = v_min(:, i) + 0.5_f*dt*dvxdt(:, i, ki)
            rho(i) = rho_min(i) + 0.5_f*dt*drhodt(i, ki)
         case (3)
            vx(:,i) = v_min(:, i) + dt*dvxdt(:, i, 3)
            rho(i) = rho_min(i) + dt*drhodt(i, 3)
         case (4)
            vx(:,i) = v_min(:, i) + &
                           dt/6_f*(dvxdt(:, i, 1) + 2._f*dvxdt(:, i, 2) + 2._f*dvxdt(:, i, 3) + dvxdt(:, i, 4))
            rho(i) = rho_min(i) + dt/6._f*(drhodt(i, 1) + 2._f*drhodt(i, 2) + 2._f*drhodt(i, 3) + drhodt(i, 4))
            x(:,i) = x(:,i) + dt*vx(:,i)
         end select
         p(i) = rh0*c**2*((rho(i)/rh0)**gamma - 1._f)/gamma

      end if
      
   end subroutine RK4_update

end module time_integration_m
